#include <iostream>
#include <LongReal_module.h>
#include <common_values.hpp>
#include "LongRealTest.hpp"

/****************************************************************************************************/
/****************************************************************************************************/
/*** 												  ***/
/***   Copyright © 2025 Пидкасистый Александр Павлович						  ***/
/*** 												  ***/
/***   Данная лицензия разрешает лицам, получившим копию данного программного обеспечения и	  ***/
/***   сопутствующей документации (далее — Программное обеспечение), безвозмездно использовать    ***/
/***   Программное обеспечение без ограничений, включая неограниченное право на использование,    ***/
/***   копирование, изменение, слияние, публикацию, распространение, сублицензирование и/или      ***/
/***   продажу копий Программного обеспечения, а также лицам, которым предоставляется данное      ***/
/***   Программное обеспечение, при соблюдении следующих условий:				  ***/
/*** 												  ***/
/***   Указанное выше уведомление об авторском праве и данные условия должны быть включены во	  ***/
/***   все копии или значимые части данного Программного обеспечения.				  ***/
/*** 												  ***/
/***   ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ «КАК ЕСТЬ», БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, ЯВНО   ***/
/***   ВЫРАЖЕННЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ, ВКЛЮЧАЯ ГАРАНТИИ ТОВАРНОЙ ПРИГОДНОСТИ, СООТВЕТСТВИЯ ПО	  ***/
/***   ЕГО КОНКРЕТНОМУ НАЗНАЧЕНИЮ И ОТСУТСТВИЯ НАРУШЕНИЙ, НО НЕ ОГРАНИЧИВАЯСЬ ИМИ. НИ В КАКОМ	  ***/
/***   СЛУЧАЕ АВТОРЫ ИЛИ ПРАВООБЛАДАТЕЛИ НЕ НЕСУТ ОТВЕТСТВЕННОСТИ ПО КАКИМ-ЛИБО ИСКАМ, ЗА УЩЕРБ   ***/
/***   ИЛИ ПО ИНЫМ ТРЕБОВАНИЯМ, В ТОМ ЧИСЛЕ, ПРИ ДЕЙСТВИИ КОНТРАКТА, ДЕЛИКТЕ ИЛИ ИНОЙ СИТУАЦИИ,   ***/
/***   ВОЗНИКШИМ ИЗ-ЗА ИСПОЛЬЗОВАНИЯ ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ ИЛИ ИНЫХ ДЕЙСТВИЙ С ПРОГРАММНЫМ     ***/
/***   ОБЕСПЕЧЕНИЕМ.										  ***/
/*** 												  ***/
/****************************************************************************************************/
/****************************************************************************************************/

using namespace std;
using namespace nmBPTypes;
using namespace nmRePrint;

/** Определение макроса, перенаправляющего вывод результатов в файл Report.txt **/
#define PRINTREPORT     // Включить макрос вывода информации в файл вместо экрана

int main() {
    string odir= "../examples/LongReal_test/output/"; 	// Расположение результатов расчетов	

    #ifdef PRINTREPORT
    /** Перенаправляем вывод в текстовый файл   **/
        const string filename = odir + "Report.txt";   	// Имя файла для вывода отчетаs
        ofstream out(filename);                 	// Откроем файл для вывода
        streambuf* coutbuf = cout.rdbuf();      	// Запомним старый буфер в переменной coutbuf
        cout.rdbuf(out.rdbuf());                	// Перенаправляем поток в файл: теперь все будет в файл
    #endif
    /**************************************************************************************************/

    setlocale(LC_ALL, "Russian");               // Установка русского языка для вывода
    srand(time(0));                             // Сбрасываем генератор случайных чисел

    const size_t headsize = 82;                 // Ширина поля для заголовка
    PrintHeader0(cout, headsize, "Программа для тестирование класса LongReal");
    LongRealTest Test;                          // Создаем объект класса тестирования
    cout << "Создали объект LongRealTest Test\n";
    Test.Init();                                // Заполняем объект тестовыми данными
    cout << "Наполнили объект тестовыми данными\n";
    Test.DcmlCopy();                            // Заполняем объект копиями данных
    cout << "Наполнили объект копиями данных\n" << endl;

    PrintHeader1(cout,headsize, "Внутреннее представление чисел типа LongReal");
    Test.View();

    PrintHeader1(cout, headsize, "Числа для тестирования");
    Test.dataView();

    /** Проверка операторов сравнения **/

    cout << endl;
    PrintHeader1(cout, headsize, "Проверка оператора сравнения на равенство (\"==\")");
    TLogical ptr = &LongReal::operator==;   // Указатель на функцию типа TLogical получает адрес функции LongReal::operator==
    Comparator ptr1 = equals;               // Вспомогательный указатель
    Test.TwiceCompare(" == ", ptr, ptr1);   // Сравниваем попарно все числа из массивов на равенство

    cout << endl;
    PrintHeader1(cout, headsize, "Проверка оператора неравенства (\"!=\")");
    ptr = &LongReal::operator!=;            // Указатель на функцию типа TLogical получает адрес функции LongReal::operator!=
    ptr1 = noeq;
    Test.TwiceCompare(" != ", ptr, ptr1);   // Сравниваем попарно все числа из массивов на неравенство

    cout << endl;
    PrintHeader1(cout, headsize, "Проверка оператора больше (\">\")");
    ptr = &LongReal::operator>;             // Указатель на функцию типа TLogical получает адрес функции LongReal::operator>
    ptr1 = bigger;
    Test.TwiceCompare(" >  ", ptr, ptr1);   // Сравниваем попарно все числа из массивов на "больше"

    cout << endl;
    PrintHeader1(cout, headsize, "Проверка оператора больше или равно (\">=\")");
    ptr = &LongReal::operator>=;            // Указатель на функцию типа TLogical получает адрес функции LongReal::operator>=
    ptr1 = ebigger;
    Test.TwiceCompare(" >= ", ptr, ptr1);   // Сравниваем попарно все числа из массивов на "больше или равно"

    cout << endl;
    PrintHeader1(cout, headsize, "Проверка оператора меньше (\"<\")");
    ptr = &LongReal::operator<;             // Указатель на функцию типа TLogical получает адрес функции LongReal::operator<
    ptr1 = lesser;
    Test.TwiceCompare(" <  ", ptr, ptr1);   // Сравниваем попарно все числа из массивов на "меньше"

    cout << endl;
    PrintHeader1(cout, headsize, "Проверка оператора меньше или равно (\"<=\")");
    ptr = &LongReal::operator<=;            // Указатель на функцию типа TLogical получает адрес функции LongReal::operator<=
    ptr1 = elesser;
    Test.TwiceCompare(" <= ", ptr, ptr1);   // Сравниваем попарно все числа из массивов на "меньше или равно"

    /** Проверка арифметических операторов **/

    cout << endl;
    PrintHeader1(cout, headsize, "Проверка оператора умножения (\"*\")");
    TArithm aptr = &LongReal::operator*;        // Указатель на функцию типа TArithm получает адрес функции LongReal::operator*
    Arithmetor aptr1 = Mult;                    // Вспомогательный указатель устанавливаем на объект "умножить"
    Test.TwiceArithmetic(" * ", aptr, aptr1);   // Умножаем попарно все числа друг на друга

    cout << endl;
    PrintHeader1(cout, headsize, "Проверка оператора сложения (\"+\")");
    aptr = &LongReal::operator+;                // Указатель на функцию типа TArithm получает адрес функции LongReal::operator+
    aptr1 = Plus;                               // Вспомогательный указатель устанавливаем на объект "плюс"
    Test.TwiceArithmetic(" + ", aptr, aptr1);   // Складываем попарно все числа друг с другом

    cout << endl;
    PrintHeader1(cout, headsize, "Проверка оператора вычитания (\"-\")");
    aptr = &LongReal::operator-;                // Указатель на функцию типа TArithm получает адрес функции LongReal::operator-
    aptr1 = Minus;                              // Вспомогательный указатель устанавливаем на объект "минус"
    Test.TwiceArithmetic(" - ", aptr, aptr1);   // Вычитаем попарно все числа друг из друга

    cout << endl;
    PrintHeader1(cout, headsize, "Проверка оператора деления (\"/\")");
    aptr = &LongReal::operator/;                // Указатель на функцию типа TArithm получает адрес функции LongReal::operator-
    aptr1 = Div;                                // Вспомогательный указатель устанавливаем на объект "делить"
    Test.TwiceArithmetic(" / ", aptr, aptr1);   // Делим попарно все числа друг на друга

    /** Сериализация и десериализация одиночного числа **/

    cout << endl;
    PrintHeader1(cout, headsize, "Запись в файл и чтение из файла одиночного числа");
    LongReal* asf = new LongReal;
    *asf = "123456789.0987654321000555";
    cout << "Записываемое число\n";
    asf->View(cout);
    if(!asf->SaveToFile(odir + "asf.dat")) cout << "Ошибка записи в файл";
    delete asf;

    LongReal* arf = new LongReal;
    if(!arf->ReadFromFile(odir + "asf.dat")) cout << "Ошибка чтения из файла";
    cout << "Прочитанное число\n";
    arf->View(cout);
    delete arf;

    /**************************************************************************************************/
    #ifdef PRINTREPORT
    /** Возвращаем перенаправление на экран и закрываем файл **/
        cout.rdbuf(coutbuf);                    // Восстанавливаем вывод на экран
        out.close();                            // Закрываем файд
    #endif // PRINTREPORT
    return 0;
}
