/**     Этот файл является частью библиотеки программного обеспечения для экономического
        моделирования, финансового анализа и планирования операционной деятельности предприятия
        "Free Operation Manager 2" (библиотека FROMA2).
**/

/****************************************************************************************************/
/****************************************************************************************************/
/*** 																						      ***/
/***   Copyright © 2025 Пидкасистый Александр Павлович										      ***/
/*** 																						      ***/
/***   Данная лицензия разрешает лицам, получившим копию данного программного обеспечения и	      ***/
/***   сопутствующей документации (далее — Программное обеспечение), безвозмездно использовать    ***/
/***   Программное обеспечение без ограничений, включая неограниченное право на использование,    ***/
/***   копирование, изменение, слияние, публикацию, распространение, сублицензирование и/или      ***/
/***   продажу копий Программного обеспечения, а также лицам, которым предоставляется данное      ***/
/***   Программное обеспечение, при соблюдении следующих условий:								  ***/
/*** 																					      	  ***/
/***   Указанное выше уведомление об авторском праве и данные условия должны быть включены во	  ***/
/***   все копии или значимые части данного Программного обеспечения.							  ***/
/*** 																						      ***/
/***   ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ «КАК ЕСТЬ», БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, ЯВНО   ***/
/***   ВЫРАЖЕННЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ, ВКЛЮЧАЯ ГАРАНТИИ ТОВАРНОЙ ПРИГОДНОСТИ, СООТВЕТСТВИЯ ПО	  ***/
/***   ЕГО КОНКРЕТНОМУ НАЗНАЧЕНИЮ И ОТСУТСТВИЯ НАРУШЕНИЙ, НО НЕ ОГРАНИЧИВАЯСЬ ИМИ. НИ В КАКОМ	  ***/
/***   СЛУЧАЕ АВТОРЫ ИЛИ ПРАВООБЛАДАТЕЛИ НЕ НЕСУТ ОТВЕТСТВЕННОСТИ ПО КАКИМ-ЛИБО ИСКАМ, ЗА УЩЕРБ   ***/
/***   ИЛИ ПО ИНЫМ ТРЕБОВАНИЯМ, В ТОМ ЧИСЛЕ, ПРИ ДЕЙСТВИИ КОНТРАКТА, ДЕЛИКТЕ ИЛИ ИНОЙ СИТУАЦИИ,   ***/
/***   ВОЗНИКШИМ ИЗ-ЗА ИСПОЛЬЗОВАНИЯ ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ ИЛИ ИНЫХ ДЕЙСТВИЙ С ПРОГРАММНЫМ     ***/
/***   ОБЕСПЕЧЕНИЕМ.																			  ***/
/*** 																						      ***/
/****************************************************************************************************/
/****************************************************************************************************/

#ifndef MANUFACT_H_INCLUDED
#define MANUFACT_H_INCLUDED

#include <vector>                   // Подключение контейнера
#include <algorithm>                // Подключение алгоритмов для работы с vector
#include <thread>                   // Потоки выполнения
#include <future>                   // Потоки выполнения
#include <mutex>                    // Блокировка потоков
#include "common_values.hpp"        // Общие типы, константы, функции
#include "serialization_module.hpp" // Методы сериализации
#include "LongReal_module.h"        // Длинная арифметика

/*************************************************************************************************************************/
/*************************************************************************************************************************/
/**                                                                                                                     **/
/**                                                                                                                     **/
/**                       Интерфейс к классам clsRecipeItem, clsManufactItem, clsManufactory                            **/
/**                                  Версия от 2025.03.13                                                               **/
/**                                                                                                                     **/
/**                                                                                                                     **/
/*************************************************************************************************************************/
/*************************************************************************************************************************/

using namespace nmBPTypes;      // Наиболее употребимые константы и типы, используемые во всех классах проекта
using namespace nmPrntSrvs;     // Константы и функции для методов визуального контроля

const string strName = "Наименование ",
             strMeas = "Ед.измерения",
             fileopenerror = "Ошибка открытия файла";

/*************************************************************************************************************************/
/**                                                                                                                     **/
/**                                             Вспомогательные функции                                                 **/
/**                                                                                                                     **/
/*************************************************************************************************************************/

inline void Sum(decimal arr1[], const decimal arr2[], size_t N);
/** Метод суммирует поэлементно два массива, результат сохраняет в первом массиве. Параметры: arr1 - первый массив,
arr2 - второй массив, N - размерность обоих массивов. Оба массива должны иметь одинаковый размер N. Метод inline для
встраивания его кода в точку вызова. Внимание!!! метод не проверяет совпадение размерности массивов **/

inline void Dif(decimal arr1[], const decimal arr2[], size_t N);
/** Метод вычитает поэлементно два массива, результат сохраняет в первом массиве. Параметры: arr1 - первый массив,
arr2 - второй массив, N - размерность обоих массивов. Оба массива должны иметь одинаковый размер N. Метод inline для
встраивания его кода в точку вызова. Внимание!!! метод не проверяет совпадение размерности массивов **/

inline decimal *Mult(const decimal arr1[], const decimal arr2[], const size_t N);
/** Метод возвращает результат умножения элементов двух массивов с одинаковыми индексами друг на друга.
Результат возвращается в виде указателя на новый массив. Параметры: arr1 - первый массив, arr2 - второй массив,
N - размерность обоих массивов. Оба массива должны иметь одинаковый размер N. Внимание!!! метод не проверяет
совпадение размерности массивов и не проверяет массивы на nullptr **/


/*************************************************************************************************************************/
/**                                                                                                                     **/
/**                                             class clsRecipeItem                                                     **/
/**                                                                                                                     **/
/*************************************************************************************************************************/

class clsRecipeItem {
/** Класс - рецептура отдельного продукта. Рецептура каждого продукта представляет собой матрицу: строки матрицы - это сырье,
использующееся в производстве продукта, столбцы - периоды производственного цикла; на пересечении строк и столбцов указывается
удельный расход сырья на производство единицы данного продукта в натуральном выражении в указанный период производственного
цикла. Период с самым большим номером соответствует периоду выхода готового продукта. **/

    private:
        string name;            // Название продукта
        string measure;         // Название единицы измерения натурального объема продукта
        size_t duration;        // Длительность производственного цикла
        size_t rcount;          // Количество позиций в номенклатуре ресурсов, требуемых для производства продукта
        strNameMeas *rnames;    // Указатель на одномерный массив с названиями ресурсов и единицами измерения. Размерность rcount
        decimal *recipeitem;    // Рецептура продукта (одномерный аналог двумерной матрицы размером rcount*duration ).
                                // Обращение к i,j-элементу матрицы производится так: *(recipeitem + duration * i + j), где
                                // i - номер строки, j - номер столбца. Условная (i,j)-ячейка матрицы содержит расход i-го
                                // ресурса на производство единицы продукта в j-м периоде от начала его производственного цикла

        decimal *CalcRawMatVolumeItem(const size_t PrCount, const size_t period, const decimal volume) const;
            /** Метод рассчитывает объем потребления ресурсов в каждом периоде технологического цикла в зависимости от
            требуемого объема готового продукта на выходе этого цикла. Метод рассчитывает потребность в ресурсах только для
            одного единичного производственного цикла (ЕПЦ). ЕПЦ - это процесс производства одного наименования продукта в
            каком-либо отдельном периоде проекта. Параметры:  PrCount - число периодов проекта, period - номер периода проекта,
            в котором требуется готовый произведенный продукт, volume - требуемый объем этого продукта. Метод возвращает
            указатель на одномерный массив, аналог двумерной матрицы, размером rcount*PrCount с рассчитанными объемами
            потребных в производстве ресурсов: число строк матрицы совпадает с числом позиций ресурсов, число столбцов - с
            длительностью проекта. Нулевой период проекта не задействуется (соответствует стартовому балансу).
            ВНИМАНИЕ!!! При вызове данного метода следует помнить о необходимости высвобождения памяти и удалении
            созданного данным методом динамического массива **/

        decimal *CalcWorkingVolumeItem(const size_t PrCount, const size_t period, const decimal volume) const;
            /** Метод рассчитывает объемы незавершенного производства для продукта, выпускаемого в конкретный период проекта.
            Параметры:  PrCount - число периодов проекта, period - номер периода проекта, в котором требуется готовый произведенный
            продукт, volume - требуемый объем этого продукта. Метод возвращает указатель на одномерный массив рассчитанных объемов
            незавершенного производства в натуральном выражении размером PrCount. ВНИМАНИЕ!!! При вызове данного метода следует
            помнить о необходимости высвобождения памяти и удалении созданного данным методом динамического массива. **/

        decimal *CalcWorkingVolume(const size_t PrCount, const strItem volume[]) const;
            /** Метод рассчитывает объемы незавершенного производства для конкретного продукта в натуральном выражении,
            выпускаемого на протяжении всего проекта. Параметры:  PrCount - число периодов проекта, volume - указатель
            на массив размерности PrCount с объемами производства продукта по периодам (план выпуска продукта). Метод
            возвращает указатель на одномерный массив рассчитанных объемов незавершенного производства в натуральном
            выражении размером PrCount. ВНИМАНИЕ!!! При вызове данного метода следует помнить о необходимости высвобождения
            памяти и удалении созданного данным методом динамического массива. **/

        decimal *CalcWorkingValueItem(const size_t _PrCount, const size_t period, const decimal rmprice[], const decimal volume) const;
            /** Метод возвращает одномерный массив сырьевой себестоимости продукта в течении единичного технологического цикла.
            Продукт выпускается в заданный период period. Размерность возвращаемого массива _PrCount. Параметры: _PrCount
            - длительность проекта, period - период выпуска продукта, rmprice[] - 2D-массив с ценами сырья размерностью
            rcount*_PrCount, volume - объем выпускаемого продукта в период period. Метод возвращает одномерный массив размерностью
            _PrCount. ВНИМАНИЕ!!! При вызове данного метода следует помнить о необходимости высвобождения памяти и удалении
            созданного данным методом динамического массива. **/

        decimal *CalcWorkingValue(const size_t _PrCount, const size_t period, const decimal rmprice[], const decimal volume) const;
            /** Метод возвращает одномерный массив аккумулированной себестоимости продукта в течении единичного технологического
            цикла. Продукт выпускается в заданный период period. Размерность возвращаемого массива _PrCount. Параметры: _PrCount
            - длительность проекта, period - период выпуска продукта, rmprice[] - 2D-массив с ценами сырья размерностью
            rcount*PrCount, volume - объем выпускаемого продуктав период period. ВНИМАНИЕ!!! При вызове данного метода следует
            помнить о необходимости высвобождения памяти и удалении созданного данным методом динамического массива. **/

        decimal *CalcWorkingBalanceItem(const size_t _PrCount, const size_t period, const decimal rmprice[], const decimal volume) const;
            /** Метод возвращает одномерный массив аккумулированной себестоимости незавершенного производства в течении единичного
            технологического цикла. Продукт выпускается в заданный период period. Размерность возвращаемого массива _PrCount.
            Параметры: _PrCount - длительность проекта, period - период выпуска продукта, rmprice[] - 2D-массив с ценами сырья
            размерностью rcount*PrCount, volume - объем выпускаемого продукта в период period. ВНИМАНИЕ!!! При вызове данного метода
            следует помнить о необходимости высвобождения памяти и удалении созданного данным методом динамического массива.**/

        decimal *CalcProductBalanceItem(const size_t _PrCount, const size_t period, const decimal rmprice[], const decimal volume) const;
            /** Метод возвращает одномерный массив себестоимости готового продукта, выпущенного в период period. Размерность
            возвращаемого массива _PrCount. Параметры: _PrCount - длительность проекта, period - период выпуска продукта, rmprice[]
            - 2D-массив с ценами сырья размерностью rcount*PrCount, volume - объем выпускаемого продукта в период period. ВНИМАНИЕ!!!
            При вызове данного метода следует помнить о необходимости высвобождения памяти и удалении созданного данным методом
            динамического массива.**/

        void clsEraser(); /** Метод "обнуляет" все поля экземпляра класса **/

        void View_f_Item(const size_t PrCount, const strItem ProPlan[], const decimal rmprice[], const string&\
        _hmcur, decimal* (clsRecipeItem::*f)(const size_t, const size_t, const decimal*, const decimal) const) const;
            /** Служебная функция для реализации визуального контроля. Позволяет реализовать контроль работоспособности
            функций: CalcWorkingValueItem, CalcWorkingValue, CalcWorkingBalanceItem и CalcProductBalanceItem. Используется
            функциями:  ViewWorkingValueItem, ViewWorkingValue, ViewWorkingBalanceItem и ViewProductBalanceItem. Параметры:
            PrCount - число периодов проекта, ProPlan[] - указатель на массив c планом выхода готовой продукции размерностью
            PrCount, rmprice[]  - 2D-массив с ценами ресурсов размерностью rcount*PrCount, где rcount - количество позиций ресурсов;
            decimal* (clsRecipeItem::*f)(const size_t, const size_t, const decimal*, const decimal) const - указатель на
            одну из функций: CalcWorkingValueItem, CalcWorkingValue, CalcWorkingBalanceItem или CalcProductBalanceItem. **/

        void View_f_Balance(const size_t _PrCount, const strItem ProPlan[], const decimal rmprice[],
        const string& _hmcur, strItem* (clsRecipeItem::*f)(const size_t, const decimal*, const strItem*) const) const;
            /** Служебная функция для реализации визуального контроля. Позволяет реализовать контроль работоспособности
            функций: CalcWorkingBalance и CalcProductBalance. Используется функциями: ViewWorkingBalance и ViewProductBalance.
            Параметры: PrCount - число периодов проекта, ProPlan[] - массив c планом выхода готовой продукции размерностью
            PrCount, rmprice[]  - 2D-массив с ценами сырья размерностью rcount*PrCount, где rcount - количество позиций сырья;
            strItem* (clsRecipeItem::*f)(const size_t, const decimal*, const strItem*) const - указатель на одну из функций
            CalcWorkingBalance или CalcProductBalance. **/

    public:

        clsRecipeItem();
            /** Конструктор без параметров. Удобен при создании экземпляра класса для дальнейшей десериализации данных из файла
            в этот экземпляр, для копирования или перемещения в экземпляр из другого объекта. **/

        clsRecipeItem(const string &_name, const string &_measure, const size_t _duration, const size_t _rcount,\
        const strNameMeas _rnames[], const decimal _recipeitem[]);
            /** Конструктор с вводом всех параметров. Параметры: &_name - ссылка на название продукта, &_measure - ссылка на
            наименование единицы измерения натурального объема продукта, _duration - длительность производственного цикла,
            _rcount - количество позиций сырья, _rnames[] - указатель на массив с наименованиями сырья и единицами измерения
            размером _rcount, _recipeitem[] - указатель на массив одномерный аналог матрицы с рецептурами размерностью
            _rcount*_duration. **/

        clsRecipeItem(const clsRecipeItem &obj);
            /** Конструктор копирования **/

        void swap(clsRecipeItem& obj) noexcept;
            /** Функция обмена значениями между объектами. Функция объявлена noexcept - не вызывающей исключения **/

        clsRecipeItem(clsRecipeItem &&obj);
            /** Конструктор перемещения **/

        clsRecipeItem &operator= (const clsRecipeItem &obj);    /** Перегрузка оператора присваивания копированием **/
        clsRecipeItem &operator= (clsRecipeItem &&obj);         /** Перегрузка оператора присваивания перемещением **/
        ~clsRecipeItem();                                       /** Деструктор**/

        /** Get - методы (Алгоритмы учета) **/

        strItem *CalcWorkingBalance(const size_t _PrCount, const decimal rmprice[], const strItem ProPlan[]) const;
            /** Метод рассчитывает объем, удельную и полную себестоимость незавершенного производства для конкретного продукта,
            выпускаемого на протяжении всего проекта. Параметры:  _PrCount - число периодов проекта, ProPlan - указатель на массив
            размерности PrCount с объемами производства продукта по периодам (план выпуска продукта), rmprice указатель на матрицу
            с ценами на сырье и материалы, размерностью rcount*PrCount. ВНИМАНИЕ!!! При вызове данного метода следует помнить о
            необходимости высвобождения памяти и удалении созданного данным методом динамического массива. **/

        strItem *CalcProductBalance(const size_t _PrCount, const decimal rmprice[], const strItem ProPlan[]) const;
            /** Метод рассчитывает объем, удельную и полную себестоимость готового продукта. Параметры:  _PrCount - число периодов
            проекта, ProPlan - указатель на массив размерности PrCount с объемами производства продукта по периодам (план выпуска
            продукта), rmprice матрица с ценами на сырье и материалы, размерностью rcount*PrCount. ВНИМАНИЕ!!! При вызове данного
            метода следует помнить о необходимости высвобождения памяти и удалении созданного данным методом динамического
            массива. **/

        decimal *CalcRawMatVolume(const size_t PrCount, const strItem volume[]) const;
            /** Метод рассчитывает и возвращает объем потребления ресурсов в натуральном выражении для всего плана
            выпуска продукта. Параметры:  PrCount - число периодов проекта, volume[] - указатель на массив размерности PrCount с
            объемами производства продукта по периодам (план выпуска продукта). Метод возвращает 2D-массив строки которого
            представляют собой название ресурсов, а столбцы - период проекта. **/

        strNameMeas *GetRawNamesItem() const;
            /** Метод возвращает указатель на вновь создаваемый динамический массив с наименованиями ресурсов
            и единицами измерения расхода ресурсов на изготовление единицы продукта. Массив создается как копия и подлежит
            удалению после использования. **/

        const strNameMeas* GetRefRawNamesItem() const;
            /** Метод возвращает константный указатель на внутренний массив с наименованиями сырья и материалов и единицами
            натурального измерения сырья. **/

        decimal* GetRecipeitem() const;
            /** Метод возвращает указатель на вновь создаваемый динамический массив с рецептурами (аналог двумерной матрицы
            размером rcount*duration). Массив создается как копия и подлежит удалению после использования. **/

        const decimal* GetRefRecipeitem() const;
            /** Метод возвращает константный указатель на внутренний массив с рецептурами (аналог двумерной матрицы размером
            rcount*duration). **/

        const size_t GetDuration() const;       // Возврат длительности производственного цикла
        const size_t GetRCount() const;         // Возврат размера массива rnames (количество позиций ресурсов)
        const string& GetName() const;          // Возврат ссылки на наименование продукта
        const string& GetMeasure() const;       // Возврат ссылки на наименование единицы измерения продукта

/** --------------------------------- Методы сериализации и десериализации ------------------------------------------------ **/

        bool StF(ofstream &_outF);
            /** Метод имплементации записи в файловую переменную текущего экземпляра класса clsRecipeItem (запись в файл, метод
            сериализации). Параметры: &_outF - экземпляр класса ofstream для записи данных. Внимание!!! файл должен быть открыт
            с флагом ios::binary (не текстовый режим!). **/

        bool SaveToFile(const string _filename);
            /** Метод записи текущего экземпляра класса в файл **/

        bool RfF(ifstream &_inF);
            /** Метод имплементации чтения из файловой переменной текущего экземпляра класса clsRecipeItem(чтение из файла, метод
            десериализации). Параметры: &_inF - экземпляр класса ifstream для чтения данных. Внимание!!! файл должен быть открыт
            с флагом ios::binary (не текстовый режим!).  **/

        bool ReadFromFile(const string _filename);
            /** Метод чтения из файла и запись в экземпляр класса **/

/** -----------------------   Методы визуального контроля функций класса clsRecipeItem   ---------------------------------  **/

        void ViewMainParametrs() const; /** Выводит на экран основные параметры класса **/
        void ViewRawNames() const;      /** Метод визуального контроля работоспособности функции GetRawNamesItem **/
        void ViewRefRawNames() const;   /** Метод визуального контроля работоспособности функции GetRefRawNamesItem **/
        void ViewRecipeitem() const;    /** Метод визуального контроля работоспособности функции GetRecipeitem. **/
        void ViewRefRecipeitem() const; /** Метод визуального контроля работоспособности функции GetRefRecipeitem. **/
        void ViewRawMatVolume(const size_t PrCount, const strItem ProPlan[]) const;
        /** Метод визуального контроля работоспособности функции CalcRawMatVolume **/

        void ViewWorkingValueItem(const size_t PrCount, const strItem ProPlan[], const decimal rmprice[],\
        const string& hmcur) const;
            /** Метод визуального контроля работоспособности функции CalcWorkingValueItem. Параметры: PrCount - число
            периодов проекта, ProPlan[] - массив c планом выхода готовой продукции размерностью PrCount, rmprice[]  -
            2D-массив с ценами сырья размерностью rcount*PrCount, где rcount - количество позиций сырья,
            hmcur - наименование валюты проекта ("RUR", "CNY", "USD", "EUR" и проч.)  **/

        void ViewWorkingValue(const size_t PrCount, const strItem ProPlan[], const decimal rmprice[],\
        const string& hmcur) const;
            /** Метод визуального контроля работоспособности функции CalcWorkingValue **/

        void ViewWorkingBalanceItem(const size_t PrCount, const strItem ProPlan[], const decimal rmprice[],\
        const string& hmcur) const;
            /** Метод визуального контроля работоспособности функции CalcWorkingBalanceItem **/

        void ViewWorkingBalance(const size_t _PrCount, const strItem ProPlan[], const decimal rmprice[],
        const string& hmcur) const;
            /** Метод визуального контроля работоспособности функции CalcWorkingBalance **/

        void ViewProductBalanceItem(const size_t PrCount, const strItem ProPlan[], const decimal rmprice[],
        const string& hmcur) const;
            /** Метод визуального контроля работоспособности функции CalcProductBalanceItem **/

        void ViewProductBalance(const size_t _PrCount, const strItem ProPlan[], const decimal rmprice[],
        const string& hmcur) const;
            /** Метод визуального контроля функции CalcProductBalance **/

};   // class clsRecipeItem

/*************************************************************************************************************************/
/**                                                                                                                     **/
/**                                             class clsManufactItem                                                   **/
/**                                                                                                                     **/
/*************************************************************************************************************************/

class clsManufactItem {
/** Класс - производство отдельного продукта. Хранит данные о потребности в сырье и материалах для выпуска продукта в заданных
объемах по заданному графику, цены на сырье и материалы, объемы, полную и удельную себестоимость изготовленного продукта,
Балансовую полную и удельную стоимость незаконченного производства. **/

    private:
        size_t PrCount;             // Количество периодов проекта
        const string* name;         // Указатель на название продукта
        const string* measure;      // Указатель на название единицы измерения продукта
        size_t duration;            // Длительность производственного цикла
        size_t rcount;              // Количество позиций в номенклатуре сырья и материалов

        clsRecipeItem *Recipe;      /** Указатель на экземпляр класса рецептур **/
        strItem *ProductPlan;       /** Указатель на массив размерностью PrCount. Содержит план по выпуску продукции,
        рассчитанные значения удельной себестоимости продукта и себестоимости партий продукции в каждом периоде проекта. **/
        decimal *RawMatPurchPlan;   /** Указатель на массив с планом закупок ресурсов в натуральном выражении по
        каждому виду ресурсов. Размерность массива rcount*PrCount **/
        decimal *RawMatPrice;       /** Указатель на массив с ценами на ресурсы в каждом периоде проекта. Размер
        массива rcount*PrCount **/
        strItem *Balance;           /** Указатель на массив со значениями объемов, балансовой стоимости незавершенного
        производства и удельной стоимости незаконченных продуктов. Размер массива совпадает с числом периодов поекта PrCount **/

        void clsEraser();           /** Метод "обнуляет" все поля класса **/

    public:
        clsManufactItem();          /** Конструктор без параметром **/

        clsManufactItem(const size_t _PrCount, const clsRecipeItem &obj);
            /** Конструктор с параметрами: _PrCount - количество периодов проекта, obj - const ссылка на объект типа
            clsRecipeItem. Объект obj копируется. **/

        clsManufactItem(const size_t _PrCount, clsRecipeItem &&obj);
            /** Конструктор с параметрами: _PrCount - количество периодов проекта, obj - rvalue ссылка на объект типа
            clsRecipeItem. Объект obj перемещается. **/

        clsManufactItem(const size_t _PrCount, const string &_name, const string &_measure, const size_t _duration, \
            const size_t _rcount, const strNameMeas _rnames[], const decimal _recipeitem[]);
            /** Конструктор с параметрами, создает класс рецептур **/

        clsManufactItem(const clsManufactItem &obj);    /** Конструктор копирования **/

        void swap(clsManufactItem& obj) noexcept;       /** Функция обмена значениями между объектами. **/

        clsManufactItem(clsManufactItem &&obj);
            /** Конструктор перемещения. После перемещения переменная obj не удаляется, только ее поля обнуляются либо
            указывают на nullptr. **/

        clsManufactItem &operator= (const clsManufactItem &obj);    /** Перегрузка оператора присваивания копированием **/
        clsManufactItem &operator= (clsManufactItem &&obj);         /** Перегрузка оператора присваивания перемещением **/
        bool operator == (const string &Rightname) const;
            /** Переопределение оператора сравнения для поиска экземпляра объекта по наименованию продукта **/

        ~clsManufactItem();                 // Деструктор

        /** Get - методы **/

        const size_t& GetPrCount() const;    // Возвращает const-ссылку на количество периодов проекта
        const size_t& GetRCount() const;     // Возвращает const-ссылку на количество позиций сырья, участвующего в производстве
        const size_t& GetDuration() const;   // Возвращает const-ссылку на длительность производственного цикла
        const string* GetName() const;      /** Возвращает const-указатель на наименование продукта. **/
        const string* GetMeasure() const;
            /** Метод возвращает константный указатель на единицу измерения натурального объема продукта. **/

        const decimal* GetRefRecipe() const;
            /** Метод возвращает константный указатель на внутренний массив с рецептурами. **/

        const strNameMeas* GetRefRawNames() const;
            /** Метод возвращает константный указатель на внутренний массив с наименованиями сырья и материалов и
            единицами натурального измерения сырья. **/

        const decimal* GetRawMatPurchPlan() const;
            /** Метод возвращает константный указатель на массив RawMatPurchPlan с объемом потребления сырья и материалов в
            натуральном выражении для всего плана выпуска продукта **/

        const decimal* GetRawMatPrice() const;
            /** Метод возвращает константный указатель на массив RawMatPrice с ценами на сырье и материалы. **/

        const strItem* GetBalance() const;
            /** Метод возвращает константный указатель на массив с объемом, удельной и полной себестоимостью незавершенного
            производства для конкретного продукта, выпускаемого на протяжении всего проекта. **/

        const strItem* GetProductPlan() const;
            /** Метод возвращает константный указатель на массив с объемом, удельной и полной себестоимостью готовой продукции для
            конкретного продукта, выпускаемого на протяжении всего проекта. **/

        /** Set - методы **/

        bool SetProductPlan(const strItem _ProductPlan[]);
            /** Метод ввода плана выпуска продукта (объем выпуска в натуральном выражении и график выпуска).
            Параметры: _Product - массив типа strItem размерностью PrCount. Используются только поля _Product.volume.  **/

        bool SetRawMatPrice(const decimal _Price[]);
            /** Метод ввода цен на ресурсы. Предполагается, что после получения складом информации о потребности
            в ресурсах, склад возвращает информацию об учетных ценах на эти ресурсы. Эта информация с помощью
            данного метода копируется в массив RawMatPrice размером rcount*PrCount. Параметры: _Price - указатель на массив
            (матрицу) цен на сырье и материалы размером rcount*PrCount. **/

        bool MoveRawMatPrice(decimal _Price[]);
            /** Метод ввода цен на сырье и материалы. Предполагается, что после получения складом информации о потребности
            в сырье и материалах, склад возвращает информацию об учетных ценах на сырье и материалы. Эта информация с помощью
            данного метода перемещается в массив RawMatPrice размером rcount*PrCount. Параметры: _Price - указатель на массив
            (матрицу) цен на сырье и материалы размером rcount*PrCount. По окончании работы указатель _Price принимает
            значение nullptr. **/

        /** Вычислительные методы **/

        bool Resize(size_t _n);
            /** Функция изменяет размеры массивов, устанавливая новое число периодов проекта, равное _n. При _n < PrCount,
            данные обрезаются, при _n > PrCount, - добавляются новые элементы массивов с нулевыми значениями. Функция
            возвращает true при удачном изменении размеров массивов, false - в противном случае **/

        void CalcRawMatPurchPlan();
            /** Метод рассчитывает объем потребления ресурсов в натуральном выражении для всего плана
            выпуска продукта и заполняет массив RawMatPurchPlan. **/

        bool CalculateItem();
            /** Метод рассчитывает объем, удельную и полную себестоимость незавершенного производства и готовой продукции
            для конкретного продукта, выпускаемого на протяжении всего проекта. **/

/** --------------------------------- Методы сериализации и десериализации ------------------------------------------------ **/

        bool StF(ofstream &_outF);
            /** Метод имплементации записи в файловую переменную текущего экземпляра класса clsManufactItem (запись в файл, метод
            сериализации). Параметры: &_outF - экземпляр класса ofstream для записи данных **/

        bool SaveToFile(const string _filename);
            /** Метод записи текущего экземпляра класса clsManufactItem в файл **/

        bool RfF(ifstream &_inF);
            /** Метод имплементации чтения из файловой переменной текущего экземпляра класса clsManufactItem (чтение из файла,
            метод десериализации). Параметры: &_inF - экземпляр класса ifstream для чтения данных **/

        bool ReadFromFile(const string _filename);
            /** Метод чтения из файла и запись в экземпляр класса clsManufactItem **/

/** -----------------------   Методы визуального контроля функций класса clsManufactItem   -------------------------------  **/

        void ViewMainParametrs() const;
            /** Метод визуального контроля функций GetPrCount, GetName, GetMeasure, GetDuration, GetRCount **/

        void ViewRefRecipe() const;
            /** Метод визуального контроля функций GetRefRecipe и GetRefRawNames **/

        void ViewRawMatPurchPlan() const;
            /** Метод визуального контроля работоспособности функций GetRCount, GetRefRawNames, GetPrCount,
            CalcRawMatPurchPlan и GetRawMatPurchPlan. **/

        void ViewRawMatPrice(const string& hmcur) const;
            /** Метод визуального контроля работоспособности функций GetRCount, GetRefRawNames, GetPrCount,
            SetRawMatPrice и GetRawMatPrice. **/

        void ViewCalculate(const string& hmcur) const;
            /** Метод визуального контроля работоспособности функций GetBalance и GetProductPlan. **/

};  // class clsManufactItem

/*************************************************************************************************************************/
/**                                                                                                                     **/
/**                                             class clsManufactory                                                    **/
/**                                                                                                                     **/
/*************************************************************************************************************************/

class clsManufactory {
/** Класс - производство всех необходимых для проекта продуктов. Позволяет осуществить расчет потребности в сырье и материалах
для выпуска продуктов в заданных объемах по заданному графику, рассчитать себестоимость изготовленных продуктов, рассчитать
объемы, балансовую стоимость и удельную стоимость незаконченного производства каждого продукта. При наличии производственной
зависимости продуктов друг от друга (когда вместо вырья в рецептуры вводятся те же самые продукты) позволяет оценить
реализуемость такой зависимости. **/

    private:
        size_t PrCount;                 // Количество периодов проекта
        size_t RMCount;                 // Полное количество позиций в номенклатуре ресурсов
        Currency hmcur;                 // Домашняя (основная) валюта ("Home Currency")
        strNameMeas *RMNames;           /** Полный массив с названиями ресурсов. Размерность RMCount. Этот массив в
        отличие от массивов clsRecipeItem::*rnames содержит полный список всех позиций сырья и материалов. Соответственно,
        RMCount >= clsRecipeItem::rcount. **/
        vector <clsManufactItem> Manuf; // Массив производства отдельных продуктов

        inline bool Checkrnames(const size_t _rcount, const strNameMeas _rnames[]);
            /** Метод проводит поиск имен из массива _rnames в массиве RMNames. В случае наличия в массиве _rnames хотя бы
            одного имени, отсутствующего в RMNames, выдает false. Если несовпадающих имен нет, то возвращает true. **/

        strItem* gettotal(const strItem* (clsManufactItem::*f)() const) const;
            /** Метод возвращает указатель на одномерный массив, являющийся аналогом двумерной матрицы с балансами незавершенного
            производства (при подстановке вместо f метода GetBalance) или планами выхода всех продуктов (при подстановке вместо
            f метода GetProductPlan) в натуральном, удельном и полном стоимостном выражении. Размер матрицы Manuf.size()*PrCount.
            Каждый элемент матрицы имеет тип strItem, т.е. имеет в своем составе значения volume, price и value для продукта.
            Массив создается в динамической памяти, после использования требует явного удаления с помощью оператора delete[].**/

    public:
        clsManufactory();
            /** Пустой конструктор. Используетя в методе emplace_back при десериализации данных из файла. **/

        clsManufactory(const size_t _PrCount, const size_t _RMCount, const strNameMeas _RMNames[], const size_t msize);
            /** Конструктор с параметрами: _PrCount - количество периодов проекта, _RMCount - полное количество позиций сырья и
            материалов, _RMNames - полный массив с названиями сырья и материалов, msize - полное количество наименований
            продуктов. **/

        clsManufactory(const clsManufactory&);              // Конструктор копирования
        void swap(clsManufactory& obj) noexcept;            // Функция обмена значениями между объектами
        clsManufactory(clsManufactory&&);                   // Конструктор перемещения
        clsManufactory& operator=(const clsManufactory&);   // Оператор присваивания копированием
        clsManufactory& operator=(clsManufactory&&);        // Оператор присваивания перемещением

        ~clsManufactory();                                          /** Деструктор **/

        /** Set - методы **/

        void SetCurrency(const Currency&);                  /** Устанавливаем основную валюту проекта **/

        bool SetManufItem(const string &_name, const string &_measure, const size_t _duration, const size_t _rcount,\
            const strNameMeas _rnames[], const decimal _recipe[], const strItem _pplan[]);
            /** Метод создания производства для конкретного продукта. Создает новый экземпляр класса clsManufactItem,
            добавляет его в вектор, вводит список сырья и материалов и рецептуры в созданное производство. Параметры:
            _name - наименование продукта, _measure - наименование единицы измерения, _duration - длительность
            производственного цикла, _rcount - число позиций сырья и материалов, участвующих в производстве данного продукта,
            _rnames - массив с наименованиями сырья, размерностью rcount, являющихся подмножеством наименований из полного
            массива с названиями сырья и материалов, _recipe - указатель на 2D-массив с рецептурами, размером rcount*duration,
            _pplan - указатель на массив размером PrCount с планом выпуска продукта. **/

        bool SetManufItem(const clsRecipeItem &obj, const strItem _pplan[]);
            /** Метод создания производства для конкретного продукта. Создает новый экземпляр класса clsManufactItem,
            добавляет его в вектор. Параметры: obj - копируемый экземпляр класса clsRecipeItem, _pplan - указатель
            на массив размером PrCount с планом выпуска продукта **/

        bool SetManufItem(clsRecipeItem &&obj, const strItem _pplan[]);
            /** Метод создания производства для конкретного продукта. Создает новый экземпляр класса clsManufactItem,
            добавляет его в вектор. Параметры: obj - перемещаемый экземпляр класса clsRecipeItem, _pplan - указатель
            на массив размером PrCount с планом выпуска продукта **/

        bool SetManufItem(const clsManufactItem &obj);
            /** Метод создания производства для конкретного продукта. Создает новый экземпляр класса clsManufactItem,
            добавляет его в вектор. Параметры: obj - копируемый экземпляр класса clsManufactItem **/

        bool SetManufItem(clsManufactItem &&obj);
            /** Метод создания производства для конкретного продукта. Создает новый экземпляр класса clsManufactItem,
            добавляет его в вектор. Параметры: obj - перемещаемый экземпляр класса clsManufactItem **/

        bool SetProdPlan(const strItem _ProdPlan[]);
            /** Метод вводит план выпуска всех продуктов в производство. Параметры: _ProdPlan - указатель на полный
            массив с планом выпуска всех продуктов, размером RMCount*PrCount **/

        /** Сервисные методы **/

        bool IncreaseCapacity(size_t msize);
            /** Метод увеличивает память вектора для добавления новых элементов. Однако сам метод вызывает копирование
            и удаление всех элементов вектора, что весьма затратно. Лучше не менять размер вектора с момента
            его использования. **/

        /** Вычислительные методы. Приводятся в очередности вызова **/

        void CalcRawMatPurchPlan(size_t bg, size_t en);
            /** Метод рассчитывает объем потребления сырья и материалов в натуральном выражении для планов
            выпуска продуктов от продукта с индексом bg до продукта с индексом en-1. **/

        void CalcRawMatPurchPlan();
            /** Метод рассчитывает объем потребления сырья и материалов в натуральном выражении для всего плана
            выпуска всех продуктов. **/

        void CalcRawMatPurchPlan_future();
            /** Метод рассчитывает объем потребления сырья и материалов в натуральном выражении для всего плана
            выпуска всех продуктов. Все расчеты запускаются в асинхронных потоках, число которых на единицу
            меньше числа ядер компьютера. **/

        void CalcRawMatPurchPlan_thread();
            /** Метод рассчитывает объем потребления сырья и материалов в натуральном выражении для всего плана
            выпуска всех продуктов. Все расчеты запускаются в потоках, число которых на единицу
            меньше числа ядер компьютера. **/

        decimal *GetRawMatPurchPlan() const;
            /** Вычислительный метод возвращает указатель на вновь создаваемый массив размером RMCount*PrCount, в котором
            содержится потребность для каждого наименования сырья в каждом периоде проекта. Потребность в сырье суммарная,
            по всем единичным производствам всех продуктов. **/

        strItem *GetRMPurchPlan() const;
            /** Вычислительный метод возвращает указатель на вновь создаваемый массив размером RMCount*PrCount, в котором
            содержится потребность для каждого наименования сырья в каждом периоде проекта. Потребность в сырье суммарная,
            по всем единичным производствам всех продуктов. Тип массива - strItem, заполнены только поля volume; поля
            price и value нулевые. **/

        bool SetRawMatPrice(const decimal _Price[]);
            /** Метод ввода цен на сырье и материалы. Предполагается, что после получения складом информации о
            потребности в сырье и материалах, склад возвращает информацию об учетных ценах на сырье и материалы.
            Данный метод вызывает одноименные методы каждого элемента вектора, которые записывают информацию о ценах
            в массивы RawMatPrice каждого единичного производства. Параметры: _Price - матрица цен на сырье и материалы
            размером RMCount*PrCount. **/

        bool Calculate(size_t bg, size_t en);
            /** Метод рассчитывает объем, удельную и полную себестоимость незавершенного производства и готовой продукции
            для продуктов в диапазоне от bg до en-1, выпускаемых на протяжении всего проекта. Метод поочередно вызывает
            методы CalculateItem для каждого единичного производства; формирует массивы продуктов и баланса незавершенного
            производства для каждого продукта из заданного диапазона **/

        bool Calculate();
            /** Метод рассчитывает объем, удельную и полную себестоимость незавершенного производства и готовой продукции
            для всех продуктов, выпускаемых на протяжении всего проекта. Метод поочередно вызывает методы CalculateItem для
            каждого единичного производства; формирует массивы продуктов и баланса незавершенного производства для каждого
            продукта **/

        bool Calculate_future();
            /** Метод рассчитывает объем, удельную и полную себестоимость незавершенного производства и готовой продукции
            для всех продуктов, выпускаемых на протяжении всего проекта. Метод поочередно вызывает методы CalculateItem для
            каждого единичного производства; формирует массивы продуктов и баланса незавершенного производства для каждого
            продукта. Все расчеты запускаются в асинхронных потоках, число которых на единицу меньше числа ядер компьютера. **/

        bool Calculate_thread();
            /** Метод рассчитывает объем, удельную и полную себестоимость незавершенного производства и готовой продукции
            для всех продуктов, выпускаемых на протяжении всего проекта. Метод поочередно вызывает методы CalculateItem для
            каждого единичного производства; формирует массивы продуктов и баланса незавершенного производства для каждого
            продукта. Все расчеты запускаются в потоках, число которых на единицу меньше числа ядер компьютера. **/

        /** Get - методы **/

        const size_t GetRMCount() const;            // Метол возвращает общее число позиций сырья и материалов
        const size_t GetPrCount() const;            // Метол возвращает число периодов проекта
        const size_t GetProdCount() const;          // Возвращает число продуктов

        const string GetCurrency() const;
            /** Возвращает основную валюту проекта в виде текстовой строки **/

        strNameMeas *GetProductDescription() const;
            /** Метод возвращает указатель на вновь создаваемый массив с именами и ед.измерения всех продуктов. **/

        const strNameMeas *GetRMNames() const;
            /** Метод возвращает const-указатель на внутренний массив с именами и ел. измерения сырья и материалов. **/

        strNameMeas *GetRawMatDescription() const;
            /** Метод возвращает указатель на вновь создаваемый массив с именами и ел. измерения сырья и материалов. **/

        strItem *GetTotalBalance() const;
            /** Метод взвращает указатель на одномерный массив, являющийся аналогом двумерной матрицы с балансами незавершенного
            производства для всех продуктов. Размер матрицы Manuf.size()*PrCount. Каждый элемент матрицы имеет тип strItem, т.е.
            имеет в своем составе значения volume, price и value для незавершенного производства. Массив создается в динамической
            памяти, после использования требует явного удаления с помощью оператора delete[]. **/

        strItem *GetTotalProduct() const;
            /** Метод взвращает указатель на одномерный массив, являющийся аналогом двумерной матрицы с планами выхода всех
            продуктов в натуральном, удельном и полном стоимостном выражении. Размер матрицы Manuf.size()*PrCount. Каждый элемент
            матрицы имеет тип strItem, т.е. имеет в своем составе значения volume, price и value для продукта. Массив создается
            в динамической памяти, после использования требует явного удаления с помощью оператора delete[].**/

        const decimal* GetRecipeItem(const string& Name) const;
            /** Метод возвращает константный указатель на внутренний массив с рецептурами для производства продукта с
            именем Name **/

        const decimal* GetRecipeItem(const size_t _ind) const;
            /** Метод возвращает константный указатель на внутренний массив с рецептурами для производства продукта с
            индексом  _ind **/

        const strNameMeas* GetRawNamesItem(const string& Name) const;
            /** Метод возвращает константный указатель на внутренний массив с наименованиями сырья и материалов в
            рецептуре продукта с именем Name **/

        const strNameMeas* GetRawNamesItem(const size_t _ind) const;
            /** Метод возвращает константный указатель на внутренний массив с наименованиями сырья и материалов в рецептуре продукта с
            индексом _ind **/

        const size_t GetDuration(const string& Name) const;
            /** Метод возвращает длительность производственного цикла в рецептуре продукта с именем Name  **/

        const size_t GetDuration(const size_t _ind) const;
            /** Метод возвращает длительность производственного цикла в рецептуре продукта с индексом _ind **/

        const size_t GetRCount(const string& Name) const;
            /** Метод возвращает число позиций сырья и материалов, участвующих в рецептуре продукта с именем
            Name (размер массива с наименованиями сырья) **/

        const size_t GetRCount(const size_t _ind) const;
            /** Метод возвращает число позиций сырья и материалов, участвующих в рецептуре продукта с индексом _ind **/

        const strNameMeas GetNameItem(const size_t _ind) const;
            /** Метод возвращает наименование продукта и единицу его измерения для продукта с с индексом _ind **/

/** --------------------------------- Методы сериализации и десериализации clsManufactory ---------------------------------- **/

        bool StF(ofstream &_outF);
            /** Метод имплементации записи в файловую переменную текущего экземпляра класса clsManufactory (метод сериализации).
            Параметры: &_outF - экземпляр класса ofstream для записи данных **/

        bool SaveToFile(const string _filename);
            /** Метод записи текущего экземпляра класса clsManufactory в файл **/

        bool RfF(ifstream &_inF);
            /** Метод имплементации чтения из файловой переменной текущего экземпляра класса clsManufactory (метод десериализации).
            Параметры: &_inF - экземпляр класса ifstream для чтения данных **/

        bool ReadFromFile(const string _filename);
            /** Метод чтения из файла и запись в экземпляр класса **/

/** -----------------------   Методы визуального контроля функций класса clsManufactory   ---------------------------------  **/

        void ViewProjectParametrs() const;  /** Метод визуального контроля функций GetPrCount, GetProdCount, GetRMCount **/
        void ViewRawMatPurchPlan() const;   /** Метод визуального контроля функции GetRawMatPlan **/
        void ViewRawMatPrice() const;       /** Метод визуального контроля работоспособности функции SetRawMatPrice. **/
        void ViewCalculate() const;         /** Метод визуального контроля работоспособности функции Calculate. **/
        void ViewBalance() const;           /** Метод визуального контроля функций GetProductDescription, GetTotalBalance **/
        void ViewProductPlan() const;       /** Метод визуального контроля функций GetProductDescription, GetTotalProduct **/
        void ViewRecipes() const;           /** Метод поочередно выводит на экран рецептуры всех продуктов **/

};  // clsManufactory

#endif // MANUFACT_H_INCLUDED
