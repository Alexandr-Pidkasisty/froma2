#ifndef FROMA2_WAREHOUSE_MODULE_H_INCLUDED
#define FROMA2_WAREHOUSE_MODULE_H_INCLUDED

/**     Этот файл является частью библиотеки программного обеспечения для экономического
        моделирования, финансового анализа и планирования операционной деятельности предприятия
        "Free Operation Manager 2" (библиотека FROMA2).
**/

/****************************************************************************************************/
/****************************************************************************************************/
/*** 																						      ***/
/***   Copyright © 2025 Пидкасистый Александр Павлович										      ***/
/*** 																						      ***/
/***   Данная лицензия разрешает лицам, получившим копию данного программного обеспечения и	      ***/
/***   сопутствующей документации (далее — Программное обеспечение), безвозмездно использовать    ***/
/***   Программное обеспечение без ограничений, включая неограниченное право на использование,    ***/
/***   копирование, изменение, слияние, публикацию, распространение, сублицензирование и/или      ***/
/***   продажу копий Программного обеспечения, а также лицам, которым предоставляется данное      ***/
/***   Программное обеспечение, при соблюдении следующих условий:								  ***/
/*** 																					      	  ***/
/***   Указанное выше уведомление об авторском праве и данные условия должны быть включены во	  ***/
/***   все копии или значимые части данного Программного обеспечения.							  ***/
/*** 																						      ***/
/***   ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ «КАК ЕСТЬ», БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, ЯВНО   ***/
/***   ВЫРАЖЕННЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ, ВКЛЮЧАЯ ГАРАНТИИ ТОВАРНОЙ ПРИГОДНОСТИ, СООТВЕТСТВИЯ ПО	  ***/
/***   ЕГО КОНКРЕТНОМУ НАЗНАЧЕНИЮ И ОТСУТСТВИЯ НАРУШЕНИЙ, НО НЕ ОГРАНИЧИВАЯСЬ ИМИ. НИ В КАКОМ	  ***/
/***   СЛУЧАЕ АВТОРЫ ИЛИ ПРАВООБЛАДАТЕЛИ НЕ НЕСУТ ОТВЕТСТВЕННОСТИ ПО КАКИМ-ЛИБО ИСКАМ, ЗА УЩЕРБ   ***/
/***   ИЛИ ПО ИНЫМ ТРЕБОВАНИЯМ, В ТОМ ЧИСЛЕ, ПРИ ДЕЙСТВИИ КОНТРАКТА, ДЕЛИКТЕ ИЛИ ИНОЙ СИТУАЦИИ,   ***/
/***   ВОЗНИКШИМ ИЗ-ЗА ИСПОЛЬЗОВАНИЯ ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ ИЛИ ИНЫХ ДЕЙСТВИЙ С ПРОГРАММНЫМ     ***/
/***   ОБЕСПЕЧЕНИЕМ.																			  ***/
/*** 																						      ***/
/****************************************************************************************************/
/****************************************************************************************************/

#include <vector>                   // Подключение контейнера vector
#include <algorithm>                // Подключение алгоритмов для работы с vector
#include <cmath>                    // Подключение математических функций
#include <type_traits>              // Классы для получения информации о типе во время компиляции
#include <thread>                   // Потоки выполнения
#include <future>                   // Потоки выполнения
#include <mutex>                    // Блокировка потоков
#include <atomic>                   // атомарная переменная для завершения потоков
#include "common_values.hpp"        // Общие типы, константы, классы и функции
#include "serialization_module.hpp" // Методы сериализации
#include "LongReal_module.h"        // Длинная арифметика
#include "progress_module.hpp"      // Индикация прогресса расчетов

/*************************************************************************************************************************/
/*************************************************************************************************************************/
/**                                                                                                                     **/
/**                                                                                                                     **/
/**                           Интерфейс к классам clsSKU, clsStorage                                                    **/
/**                                  Версия от 2025.06.11                                                               **/
/**                                                                                                                     **/
/**                                                                                                                     **/
/*************************************************************************************************************************/
/*************************************************************************************************************************/

using namespace nmBPTypes;          // Наиболее употребимые константы, типы и функции
using namespace nmPrntSrvs;         // Константы и функции для методов визуального контроля

enum AccountingMethod{FIFO = sZero, LIFO, AVG};          // Индексы принципов учета запасов
const string AccountTXT[] = {"FIFO", "LIFO", "AVERAGE"}; // Наименования принципов учета запасов
enum ChoiseData{purchase = sZero, balance, shipment};    // Выбор данных для ввода/вывода: данные закупок или отгрузок
enum PurchaseCalc{calc = sZero, nocalc};                 // Флаг разрешающий/ запрещающий рассчитывать объем закупок
const string PurchaseCalcTXT[] = {"AUTO", "MANUAL"};     // Наименования флага расчёта закупок
const string ProhibitedTXT[] = {"PROHIBITED", "ALLOWED"};// Наименование флага разрешения поступлений и отгрузок
                                                         // в одном и том же периоде
struct TLack {      /** Структура для получения информации о дефиците ресурсов и имени SKU, где есть дефицит **/
    decimal lack{dZero};    // Дефицит ресурсов
    string Name{EmpStr};    // Наименование SKU (Stock Keeping Unit - единица складского учета), где выявлен дефицит
};  // TLack

/*************************************************************************************************************************/
/**                                                                                                                     **/
/**                                                class clsSKU                                                         **/
/**                                                                                                                     **/
/*************************************************************************************************************************/

class clsSKU {      /** Склад ресурсов для одной номенклатурной позиции (Stock Keeping Unit - единица складского учета)**/
    private:
        size_t PrCount; // Количество периодов проекта. Нулевой период - период перед началом проекта (данные для стартового баланса).
        string name;    // Название номенклатурной единицы ресурсов
        string measure; // Единица измерения объемов закупок-отгрузок
        strItem *Pur;   // "Purchase". Указатель на массив из партий ресурсов, поступивших на склад (факт поступления)
        strItem *Rem;   // "Remaining". Указатель на вспомогательный массив остатков от партий ресурсов на складе на конец проекта
        strItem *Bal;   // "Balance". Указатель на массив балансовых остатков после отгрузок в каждом периоде
        strItem *Ship;  // "Shipment". Указатель на массив партий ресурсов, отгружаемых со склада по плану (план отгрузок);
                        // в качестве цен должны стоять цены, определенные по методу FIFO, LIFO или Average
        decimal lack;   // Дефицит ресурсов для отгрузки со склада; если lack>0, то отгрузка по плану невозможна
        bool indr;      // Переменная, хранящая установленное пользователем разрешение использовать закупаемые в каком-либо
                        // i-м периоде ресурсы для отгрузки в этом же периоде: True - можно, False - нельзя,
        AccountingMethod acct;  // Переменная, хранящая установленный пользователем принцип учета запасов: FIFO, LIFO или AVG
        PurchaseCalc pcalc;     // Переменная, хранящая установленный пользователем флаг для разрешения расчета закупок
        decimal share;  // Запас ресурсов на складе в каждый период, выраженный в доле от объема отгрузок за этот период

        decimal AVGcalc(const strItem P[], strItem R[], strItem S[], size_t N, bool ip);
            /** Функция рассчитывает цены и стоимость ресурсов, отгружаемых со склада в каждом периоде проекта
            по принципу AVG, формирует массив остатков с учетом плановых отгрузок и возвращает дефицит ресурсов для отгрузок.
            Параметры: P[] - указатель на массив закупок (массив изменять запрещено, const), R[] - указатель на вспомогательный
            массив, - после всех проведенных расчетов показывает остатки от каждой партии на конец проекта, S[] - - указатель
            на массив отгрузок, у которого заполнены поля S.volume (изменяется в процессе работы функции: рассчитываются поля
            price и value); N - размерность массивов закупок, остатков и отгрузок; ip - индикатор, признак того, можно ли
            использовать закупаемые в каком-либо периоде ресурсы для отгрузки в этом же периоде: "true" означает,
            что закупка осуществляется в начале каждого периода и закупаемые ресурсы могут быть использованы в
            отгрузках того же периода, "false" означает, что закупки производятся в конце каждого периода, поэтому отгрузка
            этих ресурсов может быть только в следующих периодах. ВНИМАНИЕ!!! Функция не оптимизирует план отгрузок,
            если возникает дефицит ресурсов; в периоды где возникает дефицит, расчет цен и стоимости отгружаемых
            партий НЕ КОРРЕКТЕН.**/

        decimal FLFcalc(const strItem P[], strItem R[], strItem S[], size_t N, bool ip, AccountingMethod ind);
            /** Функция рассчитывает цены и стоимость ресурсов, отгружаемых со склада в каждом периоде проекта.
            по принципу FIFO или LIFO, формирует массив остатков с учетом плановых отгрузок и возвращает дефицит ресурсов
            для отгрузок. Параметры: P[] - указатель на массив закупок (массив изменять запрещено, const), R[] - указатель на
            вспомогательный массив, - после всех проведенных расчетов показывает остатки от каждой партии на конец проекта.
            S[] - указатель на массив отгрузок, у которого заполнены поля S.volume (изменяется в процессе работы функции:
            рассчитываются поля price и value); N - размерность массивов закупок, остатков и отгрузок; ip - индикатор, признак
            того, можно ли использовать закупаемые в каком-либо периоде ресурсы для отгрузки в этом же периоде:
            "true" означает, что закупка осуществляется в начале каждого периода и закупаемые ресурсы могут быть
            использованы в отгрузках того же периода, "false" означает, что закупки производятся в конце каждого периода,
            поэтому отгрузка этих ресурсов может быть только в следующих периодах. Ind – флаг, устанавливающий
            принцип учета запасов: FIFO или LIFO.ВНИМАНИЕ!!! Функция не оптимизирует план отгрузок, если возникает дефицит
            ресурсов; в периоды где возникает дефицит, расчет цен и стоимости отгружаемых партий НЕ КОРРЕКТЕН.**/

        decimal PURcalc(strItem P[], const strItem S[], size_t N, bool ip, decimal Shr);
            /** Функция рассчитывает объемы закупок, необходимые для выполнения плана отгрузок и обеспечения заданного
            остатка ресурсов (остаток задается как доля от объема отгрузок за период) и возвращает дефицит ресурсов
            в предплановом (нулевом) периоде. Рассчитываются закупки в плановых периодах - с первого до последнего (N-1).
            Закупки в нулевой период задаются вручную и характеризуют остатки ресурсов к началу проекта (элемент
            стартового баланса). Параметры: P[] - указатель на массив закупок (изменяется в процессе работы функции), S[] -
            указатель на массив отгрузок, у которого заполнены поля S.volume (массив изменять запрещено, const); N - размерность
            массивов закупок и отгрузок; ip - признак того, можно ли использовать закупаемые в каком-либо i-м периоде
            ресурсы для отгрузки в этом же периоде: True - можно, False - нельзя, для отгрузки можно использовать только
            партии из предыдущих периодов; Shr - плановый остаток ресурсов, заданный, как доля отгрузок за период (число от 0) **/

        void BALcalc(const strItem P[], strItem B[], const strItem S[], size_t N);
            /** Функция формирует массив балансовых остатков ресурсов на складе. Функция может быть вызвана только после
            корректного расчета объемов закупок (функцией PURcalc) и цен отгрузок (функции FLFcalc или AVGcalc).
            Параметры: P[] - указатель на массив корректно рассчитанных закупок (неизменен), B[] - указатель на массив
            балансовых остатков (изменяется в процессе работы функции), S[] - указатель на массив корректно рассчитанных
            отгрузок (неизменен), N - размерность массивов закупок и отгрузок **/

    public:
        clsSKU();
            /** Пустой конструктор. **/

        clsSKU(const size_t _PrCount, const string &_name, const string &_measure, AccountingMethod _ac, bool _ind,\
            PurchaseCalc _flag, const decimal& _share, const strItem _Ship[]);
            /** Конструктор с вводом объемов отгрузок. Параметры: _PrCount - количество периодов проекта, _name - наименование
            ресурса, _measure - единица измерения ресурсов, _ac - метод учета запасов, _ind - разрешение на отгрузки и закупки в одном
            периоде, _flag - флаг ручного/ автоматического расчета закупок ресурсов, _share - Запас ресурсов на складе в
            каждый период, выраженный в доле от объема отгрузок за этот период, _Ship - массив с объемом отгрузок (заполнены
            только поля volume) **/

        clsSKU(const size_t _PrCount, const string &_name, const string &_measure, AccountingMethod _ac, bool _ind,\
            PurchaseCalc _flag, const decimal& _share);
            /** Конструктор с параметрами. Аналогичен предыдущему, но без ввода данных об отгрузках. Используется в методе
            clsStorage::RfF для десериализации. **/

        clsSKU(const clsSKU &obj);
            /** Поскольку в классе присутствует динамическое выделение памяти для переменных, необходим конструктор копирования.
            Конструктор копирования необходим для того, чтобы мы могли создавать “реальные” (а не побитовые) копии для объектов
            класса. Такая копия объекта может понадобиться в следующих случаях: при передаче объекта класса в функцию, как
            параметра по значению (а не по ссылке); при возвращении из функции объекта класса, как результата её работы; при
            инициализации  одного объекта класса другим объектом этого класса.**/

        clsSKU(clsSKU&& obj);                   /** Конструктор перемещения **/
        clsSKU& operator=(const clsSKU &obj);   /** Перегрузка оператора присваивания копированием **/
        clsSKU& operator=(clsSKU &&obj);        /** Перегрузка оператора присваивания перемещением **/
        ~clsSKU();                              /** Деструктор **/

        bool operator == (const  string& Rightname) const;
            /** Переопределение оператора сравнения для поиска экземпляра объекта по имени**/

        void swap(clsSKU& obj) noexcept;        // Функция обмена значениями между объектами

        /** Get-методы **/
        const size_t& Count() const;            // Возвращает const-ссылку на количество периодов
        const string& Name() const;             // Возвращает const-ссылку на название номенклатурной единицы складского учета
        const string& Measure() const;          // Возвращает const-ссылку на единицу натурального измерения
        string AccMethod() const;               // Возвращает принцип учета запасов в виде текстовой строки
        string Permission() const;              /** Возвращает флаг разрешения/запрещения отгрузок в одном периоде
                                                в виде текстовой строки */
        bool PermissionBool() const;            /** Возвращает флаг разрешения/запрещения отгрузок в одном периоде
                                                в виде значения типа bool **/
        string AutoPurchase() const;            // Возвращает флаг авторасчета/ ручного расчета закупок в виде строки
        const PurchaseCalc& GetAutoPurchase() const;    // Возвращает const-ссылку на флаг авторасчета/ ручного расчета закупок
        const decimal& Share() const;                   // Возвращает const-ссылку на норматив запаса ресурсов в долях от объема отгрузки

        const strItem* GetDataItem(const ChoiseData _cd, size_t _N) const;
        /** Функция возвращает данные элемента массива с индексом _N в виде const-указателя на структуру типа strItem;
        выбор массива производится значением переменной _cd (purchase - закупки, balance - остатки, shipment - отгрузки). **/

        const strItem* GetShipment() const;     /** Метод возвращает константный указатель на массив Ship **/
        const strItem* GetPurchase() const;     /** Метод возвращает константный указатель на массив Pur **/
        const strItem* GetBalance() const;      /** Метод возвращает константный указатель на массив Bal **/
        const decimal& GetLack() const;         /** Метод возвращает дефицит ресурсов для отгрузки со склада **/

        /** Set-методы **/
        void SetName(const string& _name);          // Меняет имя SKU
        void SetMeasure(const string& _measure);    // Меняем единицу измерения
        void SetPermission(bool _indr);             // Устанавливает флаг отгрузок и закупок в одном периоде
        void SetAutoPurchase(PurchaseCalc _pcalc);  // Устанавливает флаг авторасчета закупок
        void SetShare(decimal _share);              // Устанавливаем норматив запаса ресурсов на складе
        void SetAccount(AccountingMethod _acct);    // Устанавливает принцип учета запасов

        bool SetDataItem(const ChoiseData _cd, const strItem _U, size_t _N);
            /** Функция записывает в элемент массива с индексом _N значение volume, price и value из переменной _U;
        выбор массива производится значением переменной _cd. Возвращает True, если запись удалась **/

        bool SetPurchase(const strItem _unit[], size_t _count);
            /** Функция загружает данные о закупке ресурсов на склад (объемы, цены, стоимость). Параметры:  _unit[]
            - указатель на массив загружаемых данных, _count - размерность массива (может не совпадать с размерностью
            массива закупок PrCount) **/

        bool SetPurPrice(const strItem _unit[], size_t _count);
            /** Функция загружает только цены на закупаемые на склад ресурсы. Параметры:  _unit[] - указатель на массив
            загружаемых данных, _count - размерность массива (может не совпадать с размерностью массива закупок PrCount)**/

        void SetShipment(const decimal _unit[], size_t _count);
            /** Функция загружает данные о плановых отгрузках ресурсов со склада (только объемы). Параметры:
            _unit[] - указатель на массив, содержащий объемы отгрузок, _count - размерность массива (может не совпадать
            с размерностью массива закупок PrCount). **/

        /** Методы визуального контроля **/
        void View() const;                              // Выводит на экран состояние закупок, остатков, отгрузок
        void ViewData(const ChoiseData _cd) const;
        /** Метод визуального контроля состояние закупок, остатков, отгрузок; выбор массива производится значением
        переменной _cd (purchase - закупки, balance - остатки, shipment - отгрузки). **/

        /** Расчетные методы **/
        const decimal& CalcPrice();
            /** Функция рассчитывает цены и стоимость отгружаемых ресурсов в каждом периоде на основе установленного
            пользователем принципа учета запасов: FIFO, LIFO или AVERAGE, записывает результаты расчетов в массив Ship, возвращает
            величину дефицита ресурсов для обеспечения плановых отгрузок. Если дефцит не равен нулю, рассчитанные
            цены и стоимость могут нести некорректные значения. **/

        const decimal& CalcPurchase();
            /** Функция рассчитывает объемы закупок, необходимые для выполнения плана отгрузок и обеспечения заданного
            остатка ресурсов, записывает результаты расчетов в массив Pur, возвращает величину дефицита ресурсов для
            обеспечения плановых отгрузок в нулевом периоде.**/

        bool Resize(size_t _n);
            /** Функция изменяет размеры массивов типа strItem, устанавливая новое число периодов проекта, равное _n.
            При _n < PrCount, данные обрезаются, при _n > PrCount, - добавляются новые элементы массивов с нулевыми значениями.
            Функция возвращает true при удачном изменении размеров массивов, false - в противном случае **/

        TLack Calculate();
            /** Функция рассчитывает требуемый объем закупок, если выставлен флаг pcalc разрешающий расчет. Функция также
            рассчитывает цены и стоимость отгружаемой партии в соответствии с выбранным принципом FIFO, LIFO или AVG. Функция
            рассчитывает дефицит ресурсов для отгрузки со склада lack. Если lack > epsln, сделанные ранее расчеты
            объемных и стоимостных покзателей могут быть некорректными. Информация возвращается в виде структуры типа TLack **/

        /** Методы сериализациии и десериализации **/
        bool StF(ofstream &_outF);
            /** Метод имплементации записи в файловую переменную текущего экземпляра класса (запись в файл, метод сериализации).
            Параметры: &_outF - экземпляр класса ofstream для записи данных **/

        bool RfF(ifstream &_inF);
            /** Метод имплементации чтения из файловой переменной текущего экземпляра класса (чтение из файла, метод десериализации).
            Параметры: &_inF - экземпляр класса ifstream для чтения данных **/

};  // clsSKU

/*************************************************************************************************************************/
/**                                                                                                                     **/
/**                                                class clsStorage                                                     **/
/**                                                                                                                     **/
/*************************************************************************************************************************/

class clsStorage {       /** Склад ресурсов для нескольких номенклатурных позиций **/
    private:
        size_t PrCount; // Количество периодов проекта. Нулевой период - период перед началом проекта (данные для стартового баланса).
        Currency hmcur; // Домашняя (основная) валюта ("Home Currency")
        AccountingMethod acct;  // Переменная, хранящая установленный пользователем принцип учета запасов: FIFO, LIFO или AVG
        vector <clsSKU> stock;  // Контейнер склада
        atomic<bool> Calculation_Exit;  // Флаг завершения работы метода Calculate(size_t, size_t)
        clsProgress_shell<type_progress>* pshell{nullptr};  // Указатель на объект-оболочку для прогресс-бара

        strItem* getresult(const strItem* (clsSKU::*)() const) const;
            /** Метод создает и возвращает указатель на массив с объемами, учетной удельной и полной себестоимостями
            для всей номенклатуры отгрузок или закупок или остатков в зависимости от выбранной в качестве параметра
            функции типа const strItem* (clsSKU::*)() const (GetPurchase - указатель на функцию, возвращающую массив
            с закупками, GetBalance - с остатками, GetShipment - с отгрузками). **/

        template <typename T, typename U = T>
        void _setdataitem(size_t i, const T val, void (clsSKU::*f)(const U val));
            /** Для SKU с индексом i метод устанавливает новые: наименование, единицу измерения, разрешение на
            отгрузку и закупку в одном и том же периоде, флаг авторасчета/ ручного расчета закупок, норматив
            запаса ресурсов. val - новый устанавливаемый параметр. Для наименования и ед.измерения тип const string&;
            для разрешение на отгрузку и закупку const bool; для флага авторасчета const PurchaseCalc; для норматива
            остатков const decimal (вещественное число). Используется в методах: clsStorage::SetName,
            clsStorage::SetMeasure, clsStorage::SetPermission, clsStorage::SetAutoPurchase, clsStorage::SetShare. **/

        TLack Calculate(size_t bg, size_t en);
            /** Функция проверяет количество периодов у каждого SKU: если оно отличается от количества, установленного в
            переменной PRCount, то для этого SKU вызывается функция Resize, которая приводит количество периодов к заданному.
            Функция также рассчитывает требуемый объем закупок для тех SKU, у которых выставлен разрешающий такой расчет флаг.
            Для каждого SKU функция рассчитывает цены и стоимость отгружаемых партий в соответствии с выбранным принципом FIFO,
            LIFO или AVG. Функция завершает работу при нахождении первого дефицита и сообщает о размере этого дефицита и
            наименовании SKU, где найден дефицит. Дальнейшие расчеты не производятся. Информация возвращается в виде структуры
            типа TLack. Все расчеты производятся в тех SKU, чьи индексы в векторе stock лежат между bg и en. **/

    public:

        clsStorage();                                                   // Пустой конструктор
        clsStorage(size_t _pcnt, Currency _cur, AccountingMethod _ac);  // Конструктор с параметрами
        clsStorage(size_t _pcnt, Currency _cur, AccountingMethod _ac, size_t stocksize);
            /** Конструктор с созданием вектора заданного размера **/

        clsStorage(const clsStorage&);              // Конструктор копирования
        clsStorage(clsStorage&&);                   // Конструктор перемещения
        void swap(clsStorage& obj) noexcept;        // Функция обмена значениями между объектами

        clsStorage& operator=(const clsStorage&);   // Оператор присваивания копированием
        clsStorage& operator=(clsStorage&&);        // Оператор присваивания перемещением

        virtual ~clsStorage();                  // Деструктор

        /** Get-методы **/

        const size_t& ProjectCount() const;     // Возвращает количество периодов проекта
        size_t Size() const;                    // Возвращает размер вектора, равный количеству SKU
        const string& Name(size_t i) const;     // Возвращает Наименование SKU для элемента с индексом i
        const string& Measure(size_t i) const;  // Возвращает Единицу измерения SKU для элемента с индексом i
        strNameMeas* GetNameMeas() const;             /** Метод возвращает указатель на вновь создаваемый массив
        типа strNameMeas с названием ресурсов и единицами измерения для всех позиций **/

        string Permission(size_t i) const;
            /** Возвращает разрешение на отгрузку и закупку для i-го SKU в виде текстовой строки **/

        bool PermissionBool(size_t i) const;
            /** Возвращает разрешение на отгрузку и закупку для i-го SKU в виде значения типа bool **/

        string AutoPurchase(size_t i) const;
            /** Возвращает признак авторасчета закупок для i-го SKU в виде текстовой строки **/

        const size_t GetAutoPurchase(size_t i) const;
            /** Возвращает признак авторасчета закупок для i-го SKU **/

        string HomeCurrency() const;
            /** Возвращает основную валюту проекта в виде текстовой строки **/

        const size_t GetHomeCurrency() const;
            /** Возвращает основную валюту проекта в виде значения поля hmcur. **/

        string Accounting() const;              // Возвращает принцип учета в виде текстовой строки
        const decimal& Share(size_t i) const;   // Возвращает норматив запаса ресурсов в долях от объема отгрузки

        decimal* GetShipPrice();
            /** Метод создает массив с учетной себестоимостью ресурсов для всей номенклатуры и возвращает
            указатель на него. Массив является одномерным аналогом матрицы размером stock.size()*PrCount. **/

        strItem* GetShip() const;
            /** Метод создает массив с объемами, учетной удельной и полной себестоимостями для всей номенклатуры отгрузок и
            возвращает указатель на него. Массив является одномерным аналогом матрицы размером stock.size()*PrCount.**/

        strItem* GetPure() const;
            /** Метод создает массив с объемами, учетной удельной и полной себестоимостями для всей номенклатуры закупок и
            возвращает указатель на него. Массив является одномерным аналогом матрицы размером stock.size()*PrCount **/

        strItem* GetBal() const;
            /** Метод создает массив с объемами, учетной удельной и полной себестоимостями для всей номенклатуры остатков и
            возвращает указатель на него. Массив является одномерным аналогом матрицы размером stock.size()*PrCount **/

        const strItem* GetDataItem(const ChoiseData _cd, size_t index, size_t _N) const;
            /** Метод возвращает данные для SKU с индексом index и периодом _N. Данные возвращаются в виде const-указателя
            на структуру типа strItem, содержащую информацию об объемах закупки или отгрузки, ценах и стоимости; выбор
            массива производится значением переменной _cd. **/

        /** Set-методы **/

        void Set_progress_shell(clsProgress_shell<type_progress>* val);
            /** Функция присваивает указателю pshell адрес объекта val **/

        void Set_progress_message(string&& _message);
            /** Функция устанавливает новое значение сообщения во время вывода индикатора **/

         void Set_progress_maxcount(const int _mx);
            /** Функция устанавливает новое значение максимального числа итераций для индикатора прогресса **/

        void SetCount(const size_t _n);
            /** Устанавливаем количество периодов проекта**/

        void SetName(size_t i, const string& _name);
            /** Меняем наименование номенклатурной единицы (SKU) для элемента с индексом i **/

        void SetMeasure(size_t i, const string& _measure);
            /** Меняем ед.измерения номенклатурной единицы (SKU) для элемента с индексом i **/

        void SetCurrency(const Currency _cur);
        /** Устанавливаем основную валюту проекта **/

        void SetPermission(size_t i, const bool _indr);
            /** Меняем разрешение на отгрузку и закупку в одном и том же периоде для элемента с индексом i**/

        void SetAutoPurchase(size_t i, const PurchaseCalc _pcalc);
            /** Меняем флаг авторасчета/ ручного расчета закупок для элемента с индексом i **/

        void SetShare(size_t i, const decimal _share);
            /** Меняем норматив запаса ресурсов в долях от объема отгрузок в периоде для элемента с индексом i **/

        void SetAccounting(const AccountingMethod _acct);
            /** Устанавливает принцип учета запасов **/

        bool SetDataItem(const ChoiseData _cd, const strItem _U, size_t index, size_t _N);
            /** Функция записывает в элемент вектора с индексом index и период с индексом _N значение volume, price и value
            из переменной _U; выбор массива производится значением переменной _cd. Метод работает только
            с непустым вектором. В случае успешной записи, метод возвращает true.  **/

        bool SetSKU(const string& Name, const string& Measure, PurchaseCalc _flag, decimal _share, bool _perm,\
            strItem _ship[], strItem _pur[]);
            /** Метод создания склада для конкретного SKU. Создает новый экземпляр класса cksSKU непоредственно в векторе.
            Параметры: Name - наименование SKU, Measure - единица измерения SKU, _flag - флаг разрешающий авторасчет закупок,
            _share - запас ресурсов на складе в каждый период, выраженный в доле от объема отгрузок за этот период,
            _perm - флаг разрешающий/запрещающий закупки и отгрузки в одном периоде, _ship - массив отгрузок, _pur - массив
            закупок. Метод работает как с пустым, так и не пустым вектором. **/

        bool SetPurchase(size_t isku, const strItem _unit[], size_t _count);
            /** Метод загружает массив закупок _unit размером _count в индивидуальный склад с номером isku. **/

        bool SetPurPrice(const strItem _unit[]);
            /** Метод загружает цены из одномерного массива, являющегося аналогом матрицы с планами закупок всех позиций ресурсов
            в натуральном, удельном и полном стоимостном выражении. Размер матрицы RMCount*PrCount. Каждый элемент матрицы имеет
            тип strItem, т.е. имеет в своем составе значения volume, price и value для продукта. Используются только поля price. **/

        bool CheckPurchase(const strItem _pur[]) const;
            /** При флаге, запрещающем автоматический расчет закупок, массив закупок должен содержать корректные цифры, т.е
            произведение volume * price == value. Если это условие не соблюдается, расчетная себестоимость ресурсов может
            считаться некорректно. Данный метод проверяет корректность массива закупок. **/

        bool SetStorage(size_t RMCount, const strNameMeas RMNames[], decimal ShipPlan[], decimal PricePur[]);
            /** Метод ввода исходных данных в формате, совпадающим с выходным форматом strNameMeas* clsManufactory::GetRefRawNames
            и clsManufactory::decimal* GetRawMatPurchPlan(). После создания "пустого" экземпляра класса clsStorage, данный метод
            создает склады для отдельных продуктов в количестве, равном количеству позиций ресурсов, требуемых для
            производственной программы объекта типа clsManufactory (равно clsManufactory::RMCount. Параметры: RMCount - число
            номенклатурных позиций ресурсов, RMNames - массив с названиями ресурсов, размерностью RMCount;
            помимо названий в массиве присутствуют единицы измерения. ShipPlan - массив отгрузок ресурсов в производство
            для каждого наименования ресурсов в каждом периоде проекта; массив представляет собой одномерный аналог двумерной матрицы
            размером RMCount*PrCount. Для доступа к элементу с индексом i,j используется арифметика указателей: *(X+cols*i+j),
            где X - указатель на первый элемент массива, cols - число столбцов в матрице, i и j - соответственно номер строки и
            столбца в матрице. PricePur - массив цен закупаемых ресурсов размером RMCount*PrCount.
            Этот метод устанавливает для всех частных складов флаг разрешающий автоматический расчет закупок (calc),
            нулевой запас ресурсов на складе в каждый период и флаг разрешающий закупки и отгрузки в одном периоде (true);
            в дальнейшем эти параметры можно скорректировать для каждого склада отдельно другими методами класса. Данный метод
            целесообразно применять в паре с конструктором с параметрами, устанавливающим число периодов проекта, домашнюю валюту
            и принцип учета запасов (clsStorage(size_t _pcnt, Currency _cur, AccountingMethod _ac)).
            ВНИМАНИЕ!!!  массив ShipPlan - динамический, после их использования требуют удаления в ручном
            режиме оператором delete[].**/

        bool SetStorage(size_t RMCount, const strNameMeas RMNames[], strItem ShipPlan[], strItem Purchase[]);
            /** Аналогичный предыдущему, но массивы отгрузок и закупок в формате strItem, загружаются и цены и объемы **/

        bool SetData(const clsSKU &obj);
            /** Функция заносит в вектор данных информацию о конкретном SKU путем копирования экземпляра класса
            clsSKU в вектор **/

        bool SetData(clsSKU &&obj);
            /** Функция заносит в вектор данных информацию о конкретном SKU путем перемещения экземпляра класса
            clsSKU в вектор **/

        void EraseSKU(size_t _i);
            /** Метод удаляет номенклатурную позицию под номером _i и все связанные с ней данные **/

        /** Методы визуального контроля **/

        void ViewSettings() const;
            /** Функция выводит на экран информацию о настройках для расчета. К настройкам относятся параметры:
            длительность проекта, домашняя (основная) валюта, метод учета запасов, разрешение/запрет на закупки
            и отгрузки в одном периоде, признак авто/ ручного расчета закупок, норматив запаса ресурсов. **/

        void View() const;
            /** Функция выводит на экран информацию по всему складу **/

        void ViewChoise(ChoiseData _arr, ReportData flg) const;
            /** Метод визуального контроля выбранного массива для всех складов. Доступные массивы:
            _arr = purchase, массив поступлений на склад; _arr = balance, массив остатков на складе;
            _arr = shipment, массив отгрузок со склада. Параметр flg - тип выводимой информации:
            volume - в натуральном, value - в стоимостном, price - в ценовом измерении **/

        /** Расчетные методы **/

        TLack Calculate();
            /** Функция проверяет количество периодов у каждого SKU: если оно отличается от количества, установленного в
            переменной PRCount, то для этого SKU вызывается функция Resize, которая приводит количество периодов к заданному.
            Функция также рассчитывает требуемый объем закупок для тех SKU, у которых выставлен разрешающий такой расчет флаг.
            Для каждого SKU функция рассчитывает цены и стоимость отгружаемых партий в соответствии с выбранным принципом FIFO,
            LIFO или AVG. Функция завершает работу при нахождении первого дефицита и сообщает о размере этого дефицита и
            наименовании SKU, где найден дефицит. Дальнейшие расчеты не производятся. Информация возвращается в виде структуры
            типа TLack. Расчеты производятся во всех SKU. **/

        TLack Calculate_future();
            /** Функция проверяет количество периодов у каждого SKU: если оно отличается от количества, установленного в
            переменной PRCount, то для этого SKU вызывается функция Resize, которая приводит количество периодов к заданному.
            Функция также рассчитывает требуемый объем закупок для тех SKU, у которых выставлен разрешающий такой расчет флаг.
            Для каждого SKU функция рассчитывает цены и стоимость отгружаемых партий в соответствии с выбранным принципом FIFO,
            LIFO или AVG. Функция завершает работу при нахождении первого дефицита и сообщает о размере этого дефицита и
            наименовании SKU, где найден дефицит. Дальнейшие расчеты не производятся. Информация возвращается в виде структуры
            типа TLack. Все расчеты запускаются в асинхронных потоках, число которых на единицу меньше числа ядер компьютера. **/

        TLack Calculate_thread();
            /** Функция проверяет количество периодов у каждого SKU: если оно отличается от количества, установленного в
            переменной PRCount, то для этого SKU вызывается функция Resize, которая приводит количество периодов к заданному.
            Функция также рассчитывает требуемый объем закупок для тех SKU, у которых выставлен разрешающий такой расчет флаг.
            Для каждого SKU функция рассчитывает цены и стоимость отгружаемых партий в соответствии с выбранным принципом FIFO,
            LIFO или AVG. Функция завершает работу при нахождении первого дефицита и сообщает о размере этого дефицита и
            наименовании SKU, где найден дефицит. Дальнейшие расчеты не производятся. Информация возвращается в виде структуры
            типа TLack. Все расчеты запускаются в потоках, число которых на единицу меньше числа ядер компьютера. **/

        bool StF(ofstream &_outF);
            /** Метод имплементации записи в файловую переменную текущего экземпляра класса (метод сериализации).
            Параметры: &_outF - экземпляр класса ofstream для записи данных **/

        bool RfF(ifstream &_inF);
            /** Метод имплементации чтения из файловой переменной текущего экземпляра класса (метод десериализации).
            Параметры: &_inF - экземпляр класса ifstream для чтения данных **/

};  // clsStorage

#endif // FROMA2_WAREHOUSE_MODULE_H_INCLUDED
