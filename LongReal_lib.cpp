/**     Этот файл является частью библиотеки программного обеспечения для экономического
        моделирования, финансового анализа и планирования операционной деятельности предприятия
        "Free Operation Manager 2" (библиотека FROMA2).
**/

/****************************************************************************************************/
/****************************************************************************************************/
/*** 																						      ***/
/***   Copyright © 2025 Пидкасистый Александр Павлович										      ***/
/*** 																						      ***/
/***   Данная лицензия разрешает лицам, получившим копию данного программного обеспечения и	      ***/
/***   сопутствующей документации (далее — Программное обеспечение), безвозмездно использовать    ***/
/***   Программное обеспечение без ограничений, включая неограниченное право на использование,    ***/
/***   копирование, изменение, слияние, публикацию, распространение, сублицензирование и/или      ***/
/***   продажу копий Программного обеспечения, а также лицам, которым предоставляется данное      ***/
/***   Программное обеспечение, при соблюдении следующих условий:								  ***/
/*** 																					      	  ***/
/***   Указанное выше уведомление об авторском праве и данные условия должны быть включены во	  ***/
/***   все копии или значимые части данного Программного обеспечения.							  ***/
/*** 																						      ***/
/***   ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ «КАК ЕСТЬ», БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, ЯВНО   ***/
/***   ВЫРАЖЕННЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ, ВКЛЮЧАЯ ГАРАНТИИ ТОВАРНОЙ ПРИГОДНОСТИ, СООТВЕТСТВИЯ ПО	  ***/
/***   ЕГО КОНКРЕТНОМУ НАЗНАЧЕНИЮ И ОТСУТСТВИЯ НАРУШЕНИЙ, НО НЕ ОГРАНИЧИВАЯСЬ ИМИ. НИ В КАКОМ	  ***/
/***   СЛУЧАЕ АВТОРЫ ИЛИ ПРАВООБЛАДАТЕЛИ НЕ НЕСУТ ОТВЕТСТВЕННОСТИ ПО КАКИМ-ЛИБО ИСКАМ, ЗА УЩЕРБ   ***/
/***   ИЛИ ПО ИНЫМ ТРЕБОВАНИЯМ, В ТОМ ЧИСЛЕ, ПРИ ДЕЙСТВИИ КОНТРАКТА, ДЕЛИКТЕ ИЛИ ИНОЙ СИТУАЦИИ,   ***/
/***   ВОЗНИКШИМ ИЗ-ЗА ИСПОЛЬЗОВАНИЯ ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ ИЛИ ИНЫХ ДЕЙСТВИЙ С ПРОГРАММНЫМ     ***/
/***   ОБЕСПЕЧЕНИЕМ.																			  ***/
/*** 																						      ***/
/****************************************************************************************************/
/****************************************************************************************************/

#include "LongReal_module.h"
#include <limits>

//#define Debug_voice                   // Макрос вывода отладочной информации. Раскомментировать для отладки

namespace nmLongReal {
/** Наиболее употребляемые константы **/
const size_t sZero =  0,
             sOne  =  1;
const Dtype  dZero =  0,
             dMask = 256;               // Единица в девятом бите (признак NaN в текущей реализации)
const Etype  eZero =  0,
             eOne  =  1;
const unsigned short int mant = std::numeric_limits<double>::max_digits10;  // Количество разрядов числа double,
                                        // используемого при инициализации экземпляра класса LongReal
const char chZero  = '0';               // Символ нуля
const char chPoint = '.';               // Символ десятичной точки
const char chMinus = '-';               // Символ минус
const string strNaN  = "NaN";           // Not-A-Number не число
const string strInf  = "inf";           // Infinity бесконечность
const string strNInf = "-inf";          // Бсконечность со знаком минус
const string strZero = "0.0";           // Ноль
const string EmpStr = "";               // Пусто

}   // namespace nmLongReal

using namespace nmLongReal;

/*********************************** Вспомогательные функции ************************************************************/

string Corrector(const string& str) {
/** Метод возвращает строку, полученную из исходной. В возвращаемой строке присутствуют только цифровые символы,
символы точки и символ минуса, другие нецифровые символы удаляются. Незначащие нули слева и справа удаляются **/
    string tmp;                                 // Возвращаемая строка
    size_t index = sZero;                       // Позиция, с которой начинается чтение символов
    bool point = true;                          // Индикатор точки
    string::const_iterator cit = str.cbegin();  // Устанавливаем итератор в начало строки
    if(*cit==chMinus) {                         // Если первый символ строки "минус", то
        index = sOne;                           // дальнейшая обработка идет со следующего символа,
        tmp.push_back(*cit);                    // а минус записывается в первый символ новой строки
    };
    for(cit = str.cbegin()+index; cit != str.cend(); cit++) {               // Цикл по всей исходной строке
        if(isdigit(*cit)) tmp.push_back(*cit);  // Если находим символ "цифра", то записываем его в конец новой строки
        if((*cit==chPoint) && point) {          // Если находим символ первая встретившаяся "точка", то
            tmp.push_back(*cit);                // записываем ее в конец новой строки и
            point = false;                      // устанавливаем запрет на запись последующих точек
        };
    };
    for(size_t i=index; i<tmp.length(); i++) {          // В новой строке ищем нули слева и справа:
        if(*(tmp.begin()+index) == chZero)              // если находим слева, то
            tmp.erase(tmp.begin()+index);               // удаляем этот символ из новой строки;
        if((*(tmp.end()-sOne) == chZero)&& (!point))    // если находим справа и если до этого была найдена точка, то
            tmp.erase(tmp.end()-sOne);                  // удаляем этот символ из новой строки, иначе оставляем как есть
    };
    if(tmp.empty()) {                                   // Если строка получилась пустой,
        tmp.push_back(chPoint);                         // записываем в нее точку
    };
    if((index==sOne)&&(tmp.length()==sOne))             // Если строка состоит из единственного символа и он равен минусу,
        *tmp.begin() = chPoint;                         // вместо него записываем точку
    return tmp;
}   // Corrector

/*************************************************************************************************************************/
/**                                                                                                                     **/
/**                                       Методы класса LongReal                                                        **/
/**                                                                                                                     **/
/*************************************************************************************************************************/

/********************************************** Секция private ********************************************************/

inline void LongReal::setzero() {
/** Вводит в экземпляр объекта число "ноль". Ноль может быть с любым знаком, но по умолчанию создается
положительный ноль. Отрицательный ноль может возникнуть только в арифметических операциях, его присвоить нельзя.
ВНИМАНИЕ!!! Метод присваивает указателю digits значение nullptr не проверяя существование массива! **/
    sign = false;                           // Ноль считаем положительным числом
    NumCount = sZero;                       // Устанавливаем размер массива равный нулю
    if(digits) delete[] digits;             // Если массив существует, то удаляем его
    digits = nullptr;                       // Устанавливаем указатель на массив в nullptr
    exponent = MinEtype;                    // Присваиваем экспоненте минимально возможное число
}   // LongReal::setzero

inline void LongReal::setposinf() {
/** Метод устанавливает значение числа равное положительной бесконечности. ВНИМАНИЕ!!! Метод присваивает
указателю digits значение nullptr не проверяя существование массива! **/
    sign = false;                           // Положительное число
    NumCount = sZero;                       // Устанавливаем размер массива равный нулю
    if(digits) delete[] digits;             // Если массив существует, то удаляем его
    digits = nullptr;                       // Устанавливаем указатель на массив в nullptr
    exponent = MaxEtype;                    // Присваиваем экспоненте минимально возможное число
}   // LongReal::setposinf

inline void LongReal::setneginf() {
/** Метод устанавливает значение числа равное положительной бесконечности. ВНИМАНИЕ!!! Метод присваивает
указателю digits значение nullptr не проверяя существование массива! **/
    sign = true;                            // Отрицательное число
    NumCount = sZero;                       // Устанавливаем размер массива равный нулю
    if(digits) delete[] digits;             // Если массив существует, то удаляем его
    digits = nullptr;                       // Устанавливаем указатель на массив в nullptr
    exponent = MaxEtype;                    // Присваиваем экспоненте минимально возможное число
}   // LongReal::setneginf

inline void LongReal::setNaN() {
/** Метод устанавливает NaN. ВНИМАНИЕ!!! Метод создаем новый массив digits, не проверяя существование
предыдущего массива! Если NaN установить не удалось, возвращает inf. **/
    sign = false;                           // Положительное число
    NumCount = sOne;                        // Устанавливаем размер массива равный нулю
    if(digits) delete[] digits;             // Если массив существует, то удаляем его
    digits = new(nothrow) Dtype[NumCount];  // Выделяем память массиву из одного элемента
    if(digits) {                            // Если память успешно выделена, то
        *digits = dMask;                    // вводим в созданный элемент признак NaN,
        exponent = eZero;                   // присваиваем экспоненте ноль и
        return;                             // выходим
    };
    setposinf();                            // Если память не выделена, то устанавливаем inf
}   // LongReal::setNAN

void LongReal::normalize() {
/** Метод нормализует число, приводя его к виду sign * 0.d1d2...dn * 10^exponent **/
    if(!digits) return;                             // Если массива нет, то нормализовать нечего
    size_t ZeroCount = sZero;                       // Счетчик количества левых (значимых) нулей в мантиссе числа
    for(size_t i=sZero; i<NumCount; i++) {          // Считаем число левых нулей в мантиссе числа
        if(*(digits+i) == dZero) ZeroCount++;       // Если встречаем ноль, то увеличиваем счетчик и
        else break;                                 // как только нули кончились, то заканчиваем цикл
    };
    if(ovrflw(exponent, -ZeroCount)) {              // При опасности переполнения,
        return;                                     // просто выходим ничего не делая
    };
    if(ZeroCount>sZero) {                           // Если в мантиссе числа сразу после запятой есть нули, то:
        size_t TmpCount = NumCount - ZeroCount;     // Рассчитываем новую длину массива
        if(TmpCount == sZero) {                     // Если количество нулей равно длине массива, то это число ноль:
            setzero();                              // удаляем массив и устанавливаем число в ноль
            return;                                 // и выходим
        };
        Dtype* temp = new(nothrow) Dtype[TmpCount]; // Выделяем память новому массиву
        if(!temp) return;                           // Если память не выделена, то работу прекращаем
        for(size_t i=sZero; i<TmpCount; i++)        // Переписываем в новый массив данные за исключением правых нулей
            *(temp+i) = *(digits+i+ZeroCount);
        exponent -= ZeroCount;                      // Меняем экспоненту
        NumCount = TmpCount;                        // Меняем длину массива
        delete[] digits;                            // Удаляем старый массив
        digits = temp;                              // Указатель основного массива направляем на новый массив
    }
}   // LongReal::normalize

inline Dtype* LongReal::cut(const Dtype _digits[], size_t Num) {
/** Обрезает копию массива _digits с конца, оставляя его размер равный Num. Возвращает обрезанную копию **/
    size_t Cnt = Num < NumCount ? Num : NumCount;   // Защита от превышения Num > NumCount
    Dtype* temp = new(nothrow) Dtype[Cnt];          // Выделяем память массиву размером Num
    if(!temp) return nullptr;                       // Если память не выделена, то выход
    memcpy(temp, _digits, sizeof(Dtype)*Cnt);       // Копируем первые Num 'ktvtyns d yjdsq vfccbd
    return temp;
}   // LongReal::cut

inline void LongReal::Resize(const size_t _n) {
/** Обрезание массива до актуального размера, _n - новый размер **/
    if(_n < sOne) return;                   // Некорректный размер
    if(_n >= NumCount) return;              // Некорректный размер
    Dtype* temp = new(nothrow) Dtype[_n];   // Выделяем память массиву размером _n
    if(!temp) return;                       // Если память не выделена, то выход
    memcpy(temp, digits, sizeof(Dtype)*_n); // Копируем первые _n элементов массива
    std::swap(temp, digits);                // Обмениваем указатели
    delete[] temp;                          // Удаляем вспомогательный массив
    NumCount = _n;                          // Сохраняем
}   // LongReal::Resize

void LongReal::init(const string& s) {
/** Метод вводит число, представленное строкою. ВНИМАНИЕ!!! Для корректного применения метода необходимо,
чтобы указатель digits указывал на реальный массив или на nullptr **/
    size_t index;                   // Индекс строки
    bool backupsign = sign;         // Сохраняем текущее состояние знака числа
	if (*s.begin() == chMinus) {    // Если первый символ строки минус, то число отрицательное
		sign = true;                // знак отрицательного числа true
		index = sOne;               // начинать идти нужно будет не с нулевого, а с первого символа
	} else {
		sign = false;               // иначе число положительное
		index = sZero;              // и идти нужно будет с нулевого символа
	};
	size_t TmpCount = s.length() - index;       // Определяем длину массива
    Dtype* temp = new(nothrow) Dtype[TmpCount]; // Выделяем память новому массиву размером TmpCount
    if(!temp) {                                 // Если память не выделена, то
        sign = backupsign;                      // восстанавливаем знак числа
        return;                                 // и выходим; число при этом не изменяется
    };                                          // Если же память выделена успешно, то
    NumCount = TmpCount;                        // устанавливаем новую длину массива равной TmpCount
    // Предполагаем, что всё число будет целым, а значит и экспонента будет равна длине строки
    exponent = (Etype)(NumCount);               // Устанавливаем экспоненту равной длине строки
    size_t i = sZero;                                           // Индекс массива
    while (index < s.length()) {                                // Идём по всей строке,
		if(*(s.begin()+index) == chPoint)  {                    // если встретили точку, то
			exponent = (sign) ? (Etype)index-1 : (Etype)index;  // запоминаем экспоненту, так как целая часть закончилась,
            i--;                                                // уменьшаем инликатор массива на единицу
		}
		else {
            *(temp+i) = (Dtype)(*(s.begin()+index)-'0');        // преобразуем символ в цифру и записываем в массив
        };
        index++;                                                // Увеличиваем индекс строки
        i++;                                                    // Увеличиваем индекс массива
	};
	if(digits) delete[] digits;                 // Если указатель на массив не равен nullptr, то удаляем массив
	digits = LongReal::cut(temp, i);            // Присваиваем указатель копии массива temp, обрезая ее до размера i
	if(!digits) {                               // Если cut вернул nullptr, то
        delete[] temp;                          // Удаляем вспомогательный массив
        sign = false;                           // Устанавливаем число в ноль
        NumCount = sZero;
        exponent = MinEtype;
        return;                                 // и выходим
	};
	NumCount = i;                               // Актуализируем длину массива
	delete[] temp;                              // Удаляем вспомогательный массив
    LongReal::normalize();                      // Нормализуем число
}   // LongReal::init

stringstream LongReal::getstream() const {
/** Метод возвращает хранимое число в поток. Используется в публичных методах для вывода числа в
переменные типа string, long double, double, float **/
    stringstream ss;                            // Поток для операций со строкой
    if(this->isNaN()) {                         // Проверка на NaN
        ss << strNaN;                           // Выводим NaN в поток и
        return ss;                              // возвращаем поток
    };
    if(sign) ss << chMinus;                     // Проверяем знак числа, если отрицательное, то выводим в поток знак "минус"
    // Если массив в числе отсутствует и длина массива в этом числе нулевая, то проверяем экспоненту
    if(( !digits) || (NumCount==sZero)) {       // Проверяем число на ноль и бесконечность
        if(exponent==MinEtype) {                // Проверяем равенство нулю, если число - это нуль, то
            ss << strZero;                      // выводим число "ноль" в поток и
            return ss;                          // возвращаем поток
        };
        if(exponent==MaxEtype) {                // Проверяем равенство любой бесконечности, если число бесконечность, то
            ss << strInf;                       // выводим аббревиатуру бесконечности в поток и
            return ss;                          // возвращаем поток (знак + или - выведен в поток ранее)
        };
    };  // Проверка на нуль и бесконечность
    if(exponent > eZero) {                          // Если экспонента положительна, то у числа ненулевая целая часть
		Etype i = eZero;                            // Обнуляем счетчик цифр в числе
        // Выводим первые exponent цифр числа (или все цифры, если экспонента больше),
		while((i < (Etype)NumCount) && (i < exponent))
			ss << digits[i++];                      // чтобы вывести целую часть
        while (i < exponent) {                      // Если экспонента больше цифр числа,
			ss << chZero;                           // то выводим справа нули, чтобы дойти до экспоненты
			i++;
		};
        if (i < (Etype)NumCount) {                  // Если цифры ещё остались, то
			ss << chPoint;                          // выводим точку и
            while(i < (Etype)NumCount)              // выводим оставшиеся цифры как дробную часть
				ss << digits[i++];
		};
		return ss;
	};                                              // Иначе эспонента отрицательна или нулевая
    ss << chZero << chPoint;                        // Выводим нулевую целую часть с точкой в обоих случаях
	if(exponent == eZero) {                         // Если экспонента нулевая, то
        for (Etype i = eZero; i < (Etype)NumCount; i++)
			ss << digits[i];                        // выводим все цифры числа в поток
        return ss;                                  // и выходим
	};
	if(exponent < eZero) {                          // Если экспонента отрицательная, то
        for(Etype i = eZero; i < -exponent; i++)
            ss << chZero;                           // выводим |exponent| нулей
        for (size_t i = sZero; i < NumCount; i++)
			ss << digits[i];                        // выводим все цифры числа в поток
        return ss;                                  // и выходим
	};
	return ss;
}   // stringstream getstream

inline bool LongReal::ovrflw(const Etype& E1, const Etype& E2) const {
/** Возвращает true, если при сложении экспонент (E1 и E2) возможно переполнение (выход за границы
максимального и минимального числа**/
    if(E1>eZero && E2>eZero)                    // Если оба числа положительные, то проверяем превышение второго
        if(E2 > (MaxEtype-E1)) return true;     // числа над разницей между максимальным числом и первым числом
    if(E1<eZero && E2<eZero)                    // Если оба числа отрицательные, то проверяем превышение разницы
        if(E2 < (MinEtype-E1)) return true;     // между минимальным числом и первым числом над вторым числом
    return false;
}   // LongReal::ovrflw

LongReal LongReal::incrE(const Etype& _E) const {
/** Метод проверяет, что новое значение экспоненты _E больше, чем текущее. Только в этом случае метод
создает копию текущего экземпляра, увеличивает экспонету числа в копии до значения _E не изменяя самого
числа (увеличивает экспоненту и одновременно добавляет слева после точки значимые нули в массив digits
нового объекта. Совместно с методом LongReal::incrD(...) позволяет выравнить числа по экспоненте и по
количеству цифр (длине массива digits) для проведения над ними арифметических операций. **/
    LongReal res;                       // Создаем выходной объект, равный нулю
    if(this->isNaN()) {                 // Проверка на NaN
        res.setNaN();                   // Если текущий экземпляр NaN, то копию устанавливаем в NaN
        return res;                     // и возвращаем копию с NaN
    };
    if(*this == res) return res;        // Если текущий экземпляр равен +/- нулю, то возвращаем копию с нулем
    if(this->isposInf()) {              // Проверка на +inf
        res.setposinf();                // Если текущий экземпляр inf, то копию устанавливаем в inf
        return res;
    }
    if(this->isnegInf()) {              // Проверка на -inf
        res.setneginf();                // Если текущий экземпляр -inf, то копию устанавливаем в -inf
        return res;
    };
    if(_E <= exponent) {                // Если нужное значение экспоненты не больше текущего, то
        res = *this;                    // помещаем в результат копию текущего числа без изменения экспоненты,
        return res;                     // выходим и возвращаем копию текущего числа
    }
    Etype dE = _E - exponent;           // Вычисляем величину увеличения экспоненты
    if(ovrflw(exponent, dE)) {          // Проверка переполнения. Если возможно переполнение, то
        res.setNaN();                   // копию устанавливаем в NaN
        return res;                     // и возвращаем копию с NaN
    };
    res.sign = sign;                    // Сохраняем знак числа в новом объекте
    res.exponent = _E;                  // Изменяем экспоненту у результата
    size_t NewCount = NumCount+dE;      // Вычисляем длину результирующего массива
    res.NumCount = NewCount;            // Устанавливаем размер массива
    Dtype* tmp = new(nothrow) Dtype[NewCount];  // Выделяем память временному массиву
    if(!tmp) {                                  // Если помять не выделена,
        res.setNaN();                           // то устанавливаем результат в NaN
        return res;                             // и выходим
    };
    for(size_t i= sZero; i<(size_t)dE; i++)     // Первые dE элементов массива
        *(tmp+i) = dZero;                       // заполняем нулями
    for(size_t i=(size_t)dE; i<NewCount; i++ )  // Остальные элементы
        *(tmp+i) = *(digits + i -(size_t)dE);   // копируем из масива входного объекта
    res.digits = tmp;                           // Перебрасываем указатель выходного массива на tmp
    return res;                                 // и выходим
}   // LongReal LongReal::incrE

void LongReal::incrD(const size_t& _N) {
/** Метод увеличивает длину массива digits текущего экземпляра до значения _N за счет правых нулей.
Число не меняется. Если размер массива больше или равно _N, то ничего не происходит. Совместно с
методом LongReal::incrE(...) позволяет выравнить числа по экспоненте и по количеству цифр (длине
массива digits) для проведения над ними арифметических операций.**/
    if( (!digits) || (NumCount == sZero) ) return;  // Если массив отсутствует или его длина равна нулю, то ничего не делаем
    if( (digits) && (NumCount == sOne)&& (*digits == dMask)) return;    // Если в массиве признак NaN, то ничего не делаем
    if(_N > NumCount) {                             // Если новый размер больше прежнего, то:
        Dtype* tmp = new(nothrow) Dtype[_N];        // Выделяем память массиву
        if(!tmp) return;                            // Если память не выделена, то выходим без изменений
        for(size_t i=sZero; i<NumCount; i++)        // Копируем NumCount элементов из digits в новый массив
            *(tmp+i) = *(digits+i);
        for(size_t i=NumCount; i<_N; i++ )          // Оставшиеся (_N-NumCount) элементов
            *(tmp+i) = dZero;                       // заполняем нулями
        NumCount = _N;                              // Устанавливаем новую длину массиа
        Dtype* backup = digits;                     // Сохраняем указатель старого массива
        digits = tmp;                               // Текущий указатель перебрасываем на новый массив
        if(backup) delete[] backup;                 // Удаляем старый массив
    };
}   // Dtype LongReal::incrD

/********************************************** Секция public ********************************************************/

LongReal::LongReal() {
/** Конструктор по умолчанию. Создает экземпляр класса с числом ноль **/
    sign = false;                   // Ноль считаем положительным числом
    NumCount = sZero;               // Устанавливаем размер массива равный нулю
    digits = nullptr;               // Устанавливаем указатель на массив в nullptr
    exponent = MinEtype;            // Присваиваем экспоненте минимально возможное число
    #ifdef Debug_voice              // Макрос вывода отладочной информации. Работает, если определен CDtor_voice
        cout << "Default Ctor\n";   // Отладочная информация
    #endif // Debug_voice
}   // Default Ctor

LongReal::LongReal(const string& value) {
/** Конструктор с инициализацией числа из строки **/
    string::const_iterator cit = value.cbegin();    // Устанавливаем итератор в начало строки
    if((value.length()==sOne)&&(*cit==chZero)) {    // Если строка состоит из одного элемента и этот элемент равен нулю,
        sign = false;                               // Устанавливаем экземпляр класса в "ноль"
        NumCount = sZero;                           // Устанавливаем размер массива равный нулю
        digits = nullptr;                           // Устанавливаем указатель на массив в nullptr
        exponent = MinEtype;                        // Присваиваем экспоненте минимально возможное число
        return;                                     // и выходим
    };                                      // Если же строка не состоит из одного элемента и этот элемент не равен нулю, то
    string temp = Corrector(value);         // Получаем скорректированную строку во вспомогательную переменную
    if((temp.length()==sOne)&&(*temp.begin()==chPoint)) {   // Если размер строки равен одному символу, и этот символ равен точке
        sign = false;                               // Устанавливаем экземпляр класса в "ноль"
        NumCount = sZero;                           // Устанавливаем размер массива равный нулю
        digits = nullptr;                           // Устанавливаем указатель на массив в nullptr
        exponent = MinEtype;                        // Присваиваем экспоненте минимально возможное число
    }
    else {                                              // Иначе
        digits = nullptr;                               // устанавливаем указатель на массив в nullptr
        LongReal::init(temp);                           // и инициализируем данные строкой
    };
    #ifdef Debug_voice                      // Макрос вывода отладочной информации. Работает, если определен CDtor_voice
        cout << "Ctor with string parametrs\n";
    #endif // Debug_voice
}   // Ctor with string parametrs



LongReal::LongReal(const double& value) {
/** Конструктор с инициализацией числа из числа типа double **/
    if(value == dZero) {                   // Если value равно нулю, то
        digits = nullptr;                   // Устанавливаем указатель на nullptr
        LongReal::setzero();                // инициируем ноль и
        return;                             // на этом работа конструктора завершена
    };
    if(value == numeric_limits<double>::infinity()) {      // Если value равна бесконечности, то
        digits = nullptr;                   // Устанавливаем указатель на nullptr
        LongReal::setposinf();              // инициируем положительную бесконечность
        return;                             // на этом работа конструктора завершена
    };
    if(value == -numeric_limits<double>::infinity()) {     // Если value равна минус бесконечности, то
        digits = nullptr;                   // Устанавливаем указатель на nullptr
        LongReal::setneginf();              // инициируем отрицательную бесконечность
        return;                             // на этом работа конструктора завершена
    };
    if(isnan(value)) {                      // Если value равна NaN, то
        digits = nullptr;                   // Устанавливаем указатель на nullptr
        LongReal::setNaN();                 // инициируем NaN
        return;                             // на этом работа конструктора завершена
    };
    stringstream ss;                        // Создаем поток для операций со строкой
    ss << fixed << setprecision(mant) << value;  // Записываем в поток value последовательностью символов с заданным числом разрядов
    digits = nullptr;                       // устанавливаем указатель на массив в nullptr
    LongReal::init(Corrector(ss.str()));    // Инициализируем данные строкой из потока
    #ifdef Debug_voice                      // Макрос вывода отладочной информации. Работает, если определен CDtor_voice
        cout << "Ctor with double parametrs\n";
    #endif // Debug_voice
}   // Ctor with double parametrs

LongReal::LongReal(const LongReal& obj ) {
/** Конструктор копирования **/
    NumCount = obj.NumCount;                    // Копируем длину массива
    sign     = obj.sign;                        // Копируем знак числа
    exponent = obj.exponent;                    // Копируем экспоненту
    if(obj.digits) {                            // Если массив у объекта существует, то
        digits = new(nothrow) Dtype[NumCount];  // выделяем память нашему массиву
        if(!digits) {                           // Если память выделить не удалось, то
            setzero();                          // устанавливаем наше число в ноль
            return;                             // на этом работа конструктора завершена
        };                                      // Если же память выделена, то
        memcpy(digits, obj.digits, sizeof(Dtype)*NumCount);  // копируем массивы
        return;                                 // на этом работа конструктора завершена
    };
    digits = nullptr;               // Если массив у объекта НЕ существует, то устанавливаем указатель массива в nullptr
    #ifdef Debug_voice              // Макрос вывода отладочной информации. Работает, если определен CDtor_voice
        cout << "Copy Ctor\n";
    #endif // Debug_voice
}   // Copy Ctor

LongReal::LongReal(LongReal&& obj) {
/** Конструктор перемещения **/
    digits = nullptr;
    setzero();                              // Инициируем ноль в текущее число
    swap(obj);                              // Обмениваемся с объектом содержанием
    #ifdef Debug_voice                      // Макрос вывода отладочной информации. Работает, если определен CDtor_voice
        cout << "Move Ctor\n";
    #endif // Debug_voice
}   // Move Ctor

LongReal::~LongReal() {
/** Деструктор **/
    if(digits) delete[] digits;             // Если массив существует, то удаляем его
    #ifdef Debug_voice                      // Макрос вывода отладочной информации. Работает, если определен CDtor_voice
        cout << "Dtor" << endl;
    #endif // Debug_voice
}   // Dtor

LongReal& LongReal::operator=(const LongReal &obj) {
/** Перегрузка оператора присваивания копированием аналогичного объекта. Реализовано в идеоме
КОПИРОВАНИЯ-И-ЗАМЕНЫ (copy-and-swap idiom) **/
    LongReal tmp(obj);      // Вызываем конструктор копирования и получаем копию obj в переменной tmp
    swap(tmp);              // Обмениваемся содержанием с tmp
    #ifdef Debug_voice      // Макрос вывода отладочной информации. Работает, если определен CDtor_voice
        cout << "Copy operator=LongReal &obj\n";
    #endif // Debug_voice
    return *this;
}   // Copy operator=

LongReal& LongReal::operator=(const double &value) {
/** Перегрузка оператора присваивания копированием переменной типа double. Реализовано в идеоме
КОПИРОВАНИЯ-И-ЗАМЕНЫ (copy-and-swap idiom) **/
    LongReal tmp(value);    // Вызываем конструктор с инициализацией числа из числа типа double
    swap(tmp);              // Обмениваемся содержанием с tmp
    #ifdef Debug_voice                      // Макрос вывода отладочной информации. Работает, если определен CDtor_voice
        cout << "Copy operator= double &value\n";
    #endif // Debug_voice
    return *this;
}   // Copy operator= from double

LongReal& LongReal::operator=(const string &value) {
/** Перегрузка оператора присваивания копированием переменной типа string. Реализовано в идеоме
КОПИРОВАНИЯ-И-ЗАМЕНЫ (copy-and-swap idiom) **/
    LongReal tmp(value);    // Вызываем конструктор с инициализацией числа из строки
    swap(tmp);              // Обмениваемся содержанием с tmp
    #ifdef Debug_voice                      // Макрос вывода отладочной информации. Работает, если определен CDtor_voice
        cout << "Copy operator=string &value\n";
    #endif // Debug_voice
    return *this;
}   // Copy operator= from string

LongReal& LongReal::operator=(LongReal &&obj) {
/** Перегрузка оператора присваивания перемещением аналогичного объекта **/
//    if(digits) delete[] digits;     // Если массив существует, то удаляем его
    setzero();                      // Обнуляем наш экземпляр
    swap(obj);                      // Обмениваемся с объектом содержанием
    #ifdef Debug_voice                      // Макрос вывода отладочной информации. Работает, если определен CDtor_voice
        cout << "Move operator=obj\n";
    #endif // Debug_voice
    return *this;
}   // Move operator=

void LongReal::swap(LongReal& obj) noexcept {
/** Функция обмена значениями между объектами. Функция объявлена noexcept - не вызывающей исключения **/
    std::swap(NumCount, obj.NumCount);      // Обмениваем значения
    std::swap(sign, obj.sign);              // Обмениваем значения
    std::swap(exponent, obj.exponent);      // Обмениваем значения
    std::swap(digits, obj.digits);          // Обмениваем указатели
}   // LongReal::swap

void LongReal::View() const {
/** Метод визуального контроля числа **/
    cout << "sign= " << sign << endl;
    cout << "NumCount= " << NumCount << endl;
    cout << "exponent= " << exponent << endl;
    if(!digits)
        cout << "digits = nullptr" << endl;
    else {
        cout << "digits are: ";
        for(size_t i=0; i<NumCount; i++)
        cout << *(digits+i);
    };
    cout << endl << endl;
}   // View

void LongReal::ViewM() const {
/** Метод визуального контроля числа с выводом массива в столбик **/
    cout << "sign= " << sign << endl;
    cout << "NumCount= " << NumCount << endl;
    cout << "exponent= " << exponent << endl;
    if(!digits)
        cout << "digits = nullptr" << endl;
    else {
        cout << "digits are: \n";
        for(size_t i=0; i<NumCount; i++)
        cout << *(digits+i) << endl;
    };
    cout << endl << endl;
}   // ViewM

size_t LongReal::Size() const {
/** Метод возвращает размер текущего экземпляра в байтах **/
    return (sizeof(size_t) + sizeof(Stype) + sizeof(Etype) + sizeof(Dtype)* NumCount);
}   // LongReal::Size

template <typename T>
/** Возвращает число в форме string, long double, double или float **/
T LongReal::Get() const {
    T tmp;
    LongReal::getstream() >> tmp;
    return tmp;
}   // T LongReal::Get
/** Создание экземпляра шаблона необходимо, если определение шаблонной функции и ее реализация разнесены по разным файлам:
LongReal.h и LongReal.cpp. Если определение и реализация находятся в одном файле LongReal.h, то создание экземпляров
функции не требуется. **/
/** Шаблон функции сам по себе не является типом, функцией или каким-либо другим объектом. Никакой код не генерируется
из исходного файла, содержащего только определения шаблонов. Чтобы появился какой-либо код, необходимо создать экземпляр
шаблона: необходимо определить аргументы шаблона, чтобы компилятор мог сгенерировать реальную функцию (или класс из
шаблона класса) https://runebook.dev/ru/docs/cpp/language/function_template **/
template string LongReal::Get<std::string>() const;      // Явное определение создания экземпляра приводит к созданию
template long double LongReal::Get<long double>() const; // экземпляра функции или функции-члена, на которую они ссылаются.
template double LongReal::Get<double>() const;
template float LongReal::Get<float>() const;

string LongReal::LongReal::Get(const size_t n) const {
/** Функция возвращает число в форме string с заданным количеством n знаков после запятой **/
    if(this->isNaN()) return strNaN;        // Если объект равен NaN, выводим NaN и выходим
    if(this->isposInf()) return strInf;     // Если объект равен inf, выводим inf и выходим
    if(this->isnegInf()) return strNInf;    // Если объект равен -inf, выводим -inf и выходим
    char c=sZero;                           // Вспомогательная переменная
    bool ind = false;                       // Индикатор присутствия разделителя целой и дробной части (точка)
    string str="";                          // Строка, возвращаемая функцией
    stringstream sst = getstream();         // Получаем поток с числом
    while(sst.get(c) && (c!=chPoint) && !sst.eof()) // Считываем посимвольно из потока, пока не встретили точку или конец потока
        str += c;                                   // Считанные символы добавляем в строку
    if(c==chPoint) ind = true;                      // Если встретили точку, то изменяем индикатор на true
    if(ind) {                                       // Если индикатор true (в переменной "с" сидит точка), то
        if(n==0) return str;                        // Если дробные знаки не нужны (n=0), выход с возвратом строки
        str += c;                                   // иначе добавляем эту точку в строку,
        for(size_t i=sZero; i<n; i++) {             // и хотим добавить еще n символов за точкой
            sst.get(c);                             // считываем символ:
            if(sst.eof()) {             // если достигнут конец потока, то
                if(i<n) str +=chZero;   // проверяем, если i<n, то дописывем нули
                else break;
            } else
                str += c;
        };
    }
    else {                              // Если число не содержит дробной части (точку не встретили), то
        str += chPoint;                 // добавляем точку в строку
        for(size_t i=sZero; i<n; i++)
            str +=chZero;               // и дописывем нули после точки
    };
    string tail;                        // Вспомогательная переменная для очистки потока
    sst >> tail;                        // Вывод остатка потока в строку. После этого в потоке уже ничего нет
    return str;                         // Выход с возвратом строки
}   // LongReal::Get(...)

string LongReal::EGet(size_t _n) const {
/** Возвращает число в виде строки string в научной форме .ddddEn (мантисса со степенью)**/
    if(this->isNaN()) return strNaN;            // Если объект равен NaN, выводим NaN и выходим
    stringstream sst;
    if(sign) sst << chMinus;                    // Проверяем знак числа, если отрицательное, то выводим в поток знак "минус"
    // Если массив в числе отсутствует и длина массива в этом числе нулевая, то проверяем экспоненту
    if(( !digits) && (NumCount==sZero)) {       // Проверяем число на ноль и бесконечность
        if(exponent==MinEtype) {                // Проверяем равенство x нулю
            sst << strZero;                     // выводим число "ноль" в поток и
            return sst.str();                   // возвращаем строку
        };
        if(exponent==MaxEtype) {                // Проверяем равенство любой бесконечности
            sst << strInf;                      // выводим аббревиатуру бесконечности в поток и
            return sst.str();                   // возвращаем строку (знак предварительно уже выведен в поток)
        };
    };  // Проверка на нуль и бесконечность
    sst << chPoint;                             // Выводим в поток точку
    size_t n = _n > NumCount ? NumCount: _n;    // Выбираем меньшее число из _n и NumCount
    for(size_t i=0; i<n; i++)                   // Выводим n знаков после точки
        sst << *(digits+i);
    sst << 'E' << exponent;                     // Выводим экспоненту
    return sst.str();                           // Возвращаем полученную строку
}   // LongReal::EGet

LongReal& LongReal::Expchange(const Etype _exch) {
/** Метод взвращает объект, у которого экспонента изменена на величину +_exch. Для удобства можно
использовать вместо числа предопределенные константы из перечисления enum Scale: NANO=-9, MICRO=-6,
MILL=-3, KILO = 3, MEGA=6, GIGA=9. Метод позволяет использовать в качестве исходных данных числа с
очень большими или очень малыми экспонентами, которые невозможно представить в виде чисел типа
long double, double Или float, а также неудобно представлять строкой из-за слишком большой ее длины,
Достаточно ввести мантиссу числа любым доступным методом и затем увеличить экпоненту до нудного размера. **/
    if( (this->isNaN()) || (this->isZero()) || (this->isposInf()) || (this->isnegInf()) )   // Если объект NaN, +/-нуль
        return *this;                                   // или любая бесконечность, возвращаем объект
    if(ovrflw(this->exponent, _exch)) return *this;     // При опасности переполнения, возвращаем объект без изменения
    this->exponent += _exch;                            // Меняем экспоненту числа
    return *this;                                       // Возвращаем измененный объект
}   // & LongReal::Expchange

bool LongReal::isZero() const {
/** Метод возвращает true, если число равно любому нулю (положительному или отрицательному):
знак числа не проверяется. **/
    if((!digits) && (NumCount==sZero) && (exponent == MinEtype)) return true;
    return false;
}   // LongReal::isZero

bool LongReal::isposZero() const {
/** Метод возвращает true, если число равно положительному нулю: знак числа проверяется.
Может быть стоит удалить потом... **/
    if( (!sign) && (!digits) && (NumCount==sZero) && (exponent == MinEtype)) return true;
    return false;
}   // LongReal::isposZero

bool LongReal::isposInf() const {
/** Метод возвращает true, если число равно Infinity (положительная бесконечность) **/
    if((!sign) && (!digits) && (NumCount==sZero) && (exponent == MaxEtype)) return true;
    return false;
}   // LongReal::isposInf

bool LongReal::isnegInf() const {
/** Метод возвращает true, если число равно -Infinity (отрицательная бесконечность) **/
    if((sign) && (!digits) && (NumCount==sZero) && (exponent == MaxEtype)) return true;
    return false;
}   // LongReal::isnegInf

bool LongReal::isNaN() const {
/** Метод возвращает true, если число неопределено (равно NaN) **/
    if( (digits) && (NumCount==sOne) && (exponent == eZero) && (*digits == dMask) ) return true;
    return false;
}   // LongReal::isNaN

bool LongReal::operator==(const LongReal& x) const {
/** Оператор сравнивает два числа и возвращает true, если числа равны. Плюс ноль и минус ноль равны друг другу. **/
    if( this->isNaN() ) return false;           // Если любой объект сравнения NaN то объекты не равны
    if( (  !digits) && (  NumCount==sZero) && (  exponent == MinEtype) &&\
        (!x.digits) && (x.NumCount==sZero) && (x.exponent == MinEtype) ) return true; // Если оба числа нули, то true, невзирая на знак
    if (sign ^ x.sign)                          // Если знаки разные, то False
		return false;
    if (exponent != x.exponent)                 // Если экпоненты разные, то false
		return false;
    if (NumCount != x.NumCount)                 // Если количество цифр числа разные, то false
		return false;
    for (size_t i = sZero; i < NumCount; i++)   // Сравниваем каждую цифру
		if (*(digits+i) != *(x.digits+i))       // Если находим неравенство хотя бы в одной цифре, то false
			return false;
    return true;
}   // LongReal::operator==

bool LongReal::operator!=(const LongReal& x) const {
	return !(*this == x);
}   // LongReal::operator!=

LongReal LongReal::operator*(const LongReal& x) const {
/** Оператор арифметического умножения. Возвращает результат умножения двух чисел типа LongReal в виде нового объекта **/
    LongReal res;                                           // Создадим объект для вывода результата. Он содержит ноль
    if( (this->isNaN()) || (x.isNaN()) ) {                  // Проверка на NaN. Если любой из множителей NaN, то
        res.setNaN();                                       // устанавливаем результат в NaN
        return res;                                         // и выходим
    };
    res.sign = sign ^ x.sign;                               // Определяем и присваиваем знак результата
    if( this->isZero() && !x.isposInf() && !x.isnegInf() ) return res;      // Если один из сомножителей равен нулю, а второй НЕ
    if( x.isZero() && !this->isposInf() && !this->isnegInf() ) return res;  // равен любой бесконечности, то результат равен нулю
    if(this->isZero() && (x.isposInf() || x.isnegInf())) {                  // Если один из сомножителей равен нулю, а второй
        res.setNaN();                                                       // равен любой бесконечности, то результат равен NaN
        return res;
    };
    if(x.isZero() && (this->isposInf() || this->isnegInf())) {
        res.setNaN();
        return res;
    };                                                      // После проведенных проверок выше знаем что в числах нет нуля
    if((x.exponent==MaxEtype) || (exponent==MaxEtype)) {    // Если любая из экпонент максимальна, то это +/- бесконечность
        res.setposinf();                                    // Устанавливаем в результат положительную бесконечность
        res.sign = x.sign ^ sign;                           // определяем и присваиваем знак результата,
        return res;                                         // выходим и возвращаем результат
    };
    if(ovrflw(exponent, x.exponent)) {                      // В случае переполнения проверяем знаки чисел
        if( (exponent < eZero) && (x.exponent < eZero) ) {  // Если экспоненты отрицательные, то
            res.setzero();                                  // произведение равно нулю
            res.sign = x.sign ^ sign;                       // с учетом знака
            return res;
        };                                                  // При других сочетаниях знаков экспонент:
        res.setposinf();                                    // устанавливаем в результат положительную бесконечность
        res.sign = x.sign ^ sign;                           // определяем и присваиваем знак результата,
        return res;                                         // выходим и возвращаем результат
    };  // Окончание проверки на переполнения
    res.NumCount = NumCount + x.NumCount;           // Максимальная длина нового числа не больше суммы длин перемножаемых чисел
    res.exponent = exponent + x.exponent;           // Складываем экспоненты
    res.digits = new(nothrow) Dtype[res.NumCount];  // Выделяем память новому массиву
    if(!res.digits) {                               // Если массив не создан, то
        res.setNaN();                               // устанавливаем NaN (если NaN не установлен, то устанавливается inf)
        return res;                                 // и возвращаем результат
    };
    for(size_t i=sZero; i<res.NumCount; i++)        // Обнуление вновь созданного массива (в противном случае в
        *(res.digits+i) = dZero;                    // неиспользуемых элементах массива могут оказаться случайные числа
    for(size_t i = sZero; i<NumCount; i++)                              // Умножаем "в столбик":
        for(size_t j=sZero; j<x.NumCount; j++)                          // прибавляем результат произведения цифр
            *(res.digits+i+j+sOne) += (*(digits+i)) * (*(x.digits+j));  // из i-го и j-го разрядов
    // В результате такого перемножения в ячейках могли получиться двузначные числа, поэтому нужно выполнить переносы:
    const Dtype dTen = 10;
    for(size_t i=res.NumCount-1; i>sZero; i--) {
        *(res.digits+i-sOne) += *(res.digits+i)/dTen;       // добавляем к более старшему разряду десятки текущего разряда
        *(res.digits+i) %= dTen;                            // оставляем только единицы у текущего разряда
    };
    res.normalize();                                // Нормализуем число
    res.Resize(manDigits);                          // Обрезаем мантиссу до указанного значения
    return res;                                     // Возвращаем результат
}   // LongReal::operator*

LongReal LongReal::operator-() const {
/** Операция унарный минус. Возвращает объект со знаком минус **/
    LongReal res(*this);    // Создаем новый объект копированием
	res.sign = !sign;       // Меняем знак числа
	return res;             // Возвращаем объект
}   // LongReal operator-()

bool LongReal::operator>(const LongReal& x) const {
/** Оператор сравнения "больше" **/
    if((this->isNaN()) || (x.isNaN())) return false;    // Если любое из чисел неопределено, то результат false
    if(this->isZero()  && x.isZero()) return false;     // Если оба числа - +/-ноль, то неверно
    if (sign ^ x.sign) return x.sign;                   // Положительное число больше отрицательного
                                                        // Если знаки у чисел одинаковые:
    if ((exponent != x.exponent) && (!this->isNaN()) && (!x.isNaN()))   // Если экспоненты разные И числа НЕ NaN,
		return (exponent > x.exponent) ^ sign;          // то больше число с большей экспонентой с учётом знака
                                                        // Если экспоненты у чисел одинаковые:
    if((this->isZero()) && (!x.isZero())) return sign;  // Если первое - плюс ноль, а второе не ноль, то второе больше первого
    if((!this->isZero()) && (x.isZero())) return !sign; // Если первое число - не ноль, а второе плюс ноль - то первое больше
    if(( this->isposInf()) && (!x.isposInf())) return true;  // Первое +бесконечность, второе НЕ +бесконечность - верно
    if((!this->isposInf()) && ( x.isposInf())) return false; // ПЕрвое НЕ +бесконечность, второе +бесконечность - ложь
    if(( this->isnegInf()) && (!x.isnegInf())) return false; // Первое -бесконечность, второе - любое - ложь
    if((!this->isnegInf()) && ( x.isnegInf())) return true;  // ПЕрвое НЕ -бесконечность, второе -бесконечность - верно
    size_t NMAX = max(this->NumCount, x.NumCount);      // Определяем максимальную длину у двух массивов
    LongReal DD1(*this);                                // Делаем копию текущего числа
    LongReal DD2(x);                                    // Делаем копию второго числа
    DD1.incrD(NMAX);                                    // Выравниваем длины массивов у обоих массивов
    DD2.incrD(NMAX);                                    // до значения NMAX
    if(DD1.NumCount != DD2.NumCount) return false;      // если выравнять длины массивов не удалось, то выходим с false
    for(size_t i=sZero; i<NMAX; i++)                              // Сравниваем последовательно цифры двух массивов между собой:
        if( *(DD1.digits+i) != *(DD2.digits+i) )                  // от старших разрядов к младшим. Если они не равны, то:
            return ( *(DD1.digits+i) > *(DD2.digits+i) ) ^ sign;  // выходим из цикла и возвращаем результат сравнения с учетом знака
    return false;                   // Возвращаем false, если все цифры массива D1 меньше соответствующих цифр массива D2
}   // LongReal::operator>

bool LongReal::operator<(const LongReal& x) const {
/** Оператор сравнения "меньше" **/
    if((this->isNaN()) || (x.isNaN())) return false;    // Если любое из чисел неопределено, то неверно
    return !(*this > x || *this == x);
}   // LongReal::operator<

bool LongReal::operator>=(const LongReal& x) const {
/** Оператор сравнения "больше или равно" **/
    if((this->isNaN()) || (x.isNaN())) return false;    // Если любое из чисел неопределено, то неверно
    return *this > x || *this == x;
}   // LongReal::operator>=

bool LongReal::operator<=(const LongReal& x) const {
/** Оператор сравнения "меньше или равно" **/
    if((this->isNaN()) || (x.isNaN())) return false;    // Если любое из чисел неопределено, то неверно
    return *this < x || *this == x;
}   // LongReal::operator<=

LongReal LongReal::operator+(const LongReal& x) const {
/** Оператор арифметического сложения. Возвращает результат сложения двух чисел типа LongReal **/
    if(this->isZero()) return x;    // Если мы равны нулю, то возвращаем x
    if(x.isZero()) return *this;    // Если x равен нулю, то возвращаем себя
    LongReal E1;                    // Создаем объект
    E1.setNaN();                    // Устанавливаем в этом объекте NaN
    if(this->isNaN() || x.isNaN()) return E1;   // Если любой из слогаемых NaN, результат NaN
    if(((this->isposInf()) && ( x.isnegInf())) || ((x.isposInf()) && ( this->isnegInf()))) return E1; // Сложение противоположных
                                    // бесконечностей дает неопределенность
    E1.setposinf();                 // Присваиваем "плюс бесконечность"
    LongReal E2;                    // Создаем объект и
    E2.setneginf();                 // присваиваем ему "минус бесконечность"
    if(((this->isposInf()) && (!x.isnegInf())) || ((x.isposInf()) && (!this->isnegInf()))) return E1; // Сложение числа с бесконечностью
    if(((this->isnegInf()) && (!x.isposInf())) || ((x.isnegInf()) && (!this->isposInf()))) return E2; // дает эту же бесконечность
    LongReal res;                                       // Создаем выходной объект
    if(!(sign ^ x.sign)) {                              // Если знаки одинаковые
        Etype EMAX = max(this->exponent, x.exponent);   // Находим максимальную степень из степеней двух чисел
        if(ovrflw(EMAX, eOne)) {                        // Проверяем возможность переполнения, если она есть
            res.setNaN();                               // устанавливаем новый объект в NaN
            return res;                                 // выходим и возвращаем NaN
        };
        E1 = this->incrE(EMAX);                         // Используем ранее созданные вспомогательные переменные как копии
        E2 = x.incrE(EMAX);                             // основных и выравниваем у них степень
        if(E1.isNaN() || E2.isNaN()) {                  // Если при изменении экспонент произошла ошибка, то
            res.setNaN();                               // Устанавливаем результат в NaN
            return res;                                 // и выходим
        };
        size_t NMAX = max(E1.NumCount, E2.NumCount);    // Находим максимальный размер массива из двух массивов
        E1.incrD(NMAX);                                 // Увеличиваем длину первого массива
        E2.incrD(NMAX);                                 // Увеличиваем длину второго массива
        if( (E1.NumCount != NMAX) || (E2.NumCount != NMAX) ) {  // Если длины массивов выравнять не удалось, то
            res.setNaN();                                       // устанавливаем результат в NaN
            return res;                                         // и выходим
        };
        res.sign = E1.sign;                             // Знак выходного числа равен знаку одного из чисел, например E1
        res.NumCount = NMAX+sOne;                       // Длина массива выходного числа равна NMAX+1
        res.exponent = EMAX + eOne;                     // Экспонента выходного числа равна EMAX + 1
        res.digits = new Dtype[res.NumCount];           // Выделяем память новому объекту
        if(!res.digits) {                               // Если память не выделена, то
            res.setNaN();                               // устанавливаем выходное число в NaN и
            return res;                                 // выходим
        };
        for(size_t i=sZero; i<res.NumCount; i++)        // Обнуляем каждый элемент массива
            *(res.digits+i) = dZero;
                                                        // Сложение цифр
        for(size_t i=sZero; i<NMAX; i++) {              // Складываем попарно элементы массива,
            *(res.digits+i+sOne) = *(E1.digits+i) + *(E2.digits+i);
        };
        for(size_t i=NMAX; i>sZero; i--) {              // Избавляемся от переполнения разрядов:
            *(res.digits+i-1) += *(res.digits+i)/10;    // прибавляем к более старшему разряду десятки текущего
            *(res.digits+i) %= 10;                      // оставляем у текущего разряда только единицы
        };
        res.normalize();                                // Нормализуем вновь полученное число
        res.Resize(manDigits);                          // Обрезаем мантиссу до указанного значения
        return res;                                     // Возвращаем число
    };
    return *this - (-x);            // Если знаки складываемых чисел разные, то из первого вычитаем второе с обратным знаком
}   // LongReal::operator+

LongReal LongReal::operator-(const LongReal& x) const {
/** Оператор арифметического вычитания. Возвращает результат вычитания двух чисел типа LongReal **/
    if(x.isZero()) return *this;    // Если x равен нулю, то возвращаем себя
    if(this->isZero()) return -x;   // Если мы равны нулю, то возвращаем -x
    LongReal E1;                    // Создаем объект и
    E1.setNaN();                    // устанавливаем его в NaN
    if(this->isNaN() || x.isNaN()) return E1;   // Если любой из вычитаемых NaN, результат NaN
    if( ((this->isposInf()) && ( x.isposInf())) || ((x.isnegInf()) && ( this->isnegInf())) ) return E1;
    E1.setposinf();                 // присваиваем E1 "плюс бесконечность"
    LongReal E2;                    // Создаем объект и
    E2.setneginf();                 // присваиваем ему "минус бесконечность"
    if( ((this->isposInf()) && (!x.isposInf())) || ((x.isnegInf()) && (!this->isnegInf())) ) return E1;
    if( ((this->isnegInf()) && (!x.isnegInf())) || ((x.isposInf()) && (!this->isposInf())) ) return E2;
    LongReal res;                                       // Создаем выходной объект
    if(!(sign ^ x.sign)) {                              // Если знаки одинаковые
        Etype EMAX = max(this->exponent, x.exponent);   // Находим максимальную степень из степеней двух чисел
        if(ovrflw(EMAX, eOne)) {                        // Проверяем возможность переполнения, если она есть
            res.setNaN();                               // устанавливаем новый объект в NaN
            return res;                                 // выходим и возвращаем NaN
        };
        E1 = this->incrE(EMAX);                         // Создаем вспомогательные переменные как копии
        E2 = x.incrE(EMAX);                             // основных и выравниваем у них степень
        if(E1.isNaN() || E2.isNaN()) {                  // Если при изменении экспонент произошла ошибка, то
            res.setNaN();                               // Устанавливаем результат в NaN
            return res;                                 // и выходим
        };
        size_t NMAX = max(E1.NumCount, E2.NumCount);    // Находим максимальный размер массива из двух массивов
        E1.incrD(NMAX);                                 // Увеличиваем длину первого массива
        E2.incrD(NMAX);                                 // Увеличиваем длину второго массива
        if( (E1.NumCount != NMAX) || (E2.NumCount != NMAX) ) {  // Если длины массивов выравнять не удалось, то
            res.setNaN();                                       // устанавливаем результат в NaN
            return res;                                         // и выходим
        };
        res.sign = E1.sign;                             // Знак выходного числа равен знаку одного из чисел, например E1
        res.NumCount = NMAX+sOne;                       // Длина массива выходного числа равна NMAX+1
        res.exponent = EMAX + 1;                        // Экспонента выходного числа равна EMAX + 1
        res.digits = new Dtype[res.NumCount];           // Выделяем память новому объекту
        if(!res.digits) {                               // Если память не выделена, то
            res.setNaN();                               // устанавливаем выходное число в NaN и
            return res;                                 // выходим
        };
        for(size_t i=sZero; i<res.NumCount; i++)        // Обнуляем каждый элемент массива
            *(res.digits+i) = dZero;
                                                        // Вычитание цифр
        LongReal* Big = nullptr;                        // Вспомогательные указатели: Big - наибольший
        LongReal* Lit = nullptr;                        // Lit - наименьший
        if(fabs(E1)>fabs(E2)) {                         // Находим большее по модулю число
            Big = &E1;                                  // Big указывает на большее по модулю число
            Lit = &E2;                                  // Lit указывает на меньшее по модулю число
        } else {
            Big = &E2;
            Lit = &E1;
            res.sign = !res.sign;                       // Меняем знак результата
        }
        for(size_t i=sZero; i<NMAX; i++) {              // Вычитаем элементы массива
            *(res.digits+i+sOne) = *(Big->digits+i) - *(Lit->digits+i);
        };
        for(size_t i=NMAX; i>sZero; i--) {              // Избавляемся от переполнения разрядов:
            if( *(res.digits+i)< dZero ) {              // Если текущий разряд стал меньше нуля, то
                *(res.digits+i) += 10;                  // занимаем у предыдущего, прибавляя 10 к текущему
                (*(res.digits+i-1))--;                  // уменьшаем на 1 предыдущий разряд
            }
        };
        res.normalize();                                // Нормализуем вновь полученное число
        res.Resize(manDigits);                          // Обрезаем мантиссу до указанного значения
        return res;                                     // Возвращаем число
    };
    return *this + (-x);        // Если знаки вычитаемых чисел разные, то складываем числа, поменяв знак у второго
}   // LongReal::operator-

LongReal& LongReal::operator-=(const LongReal& x) {
/** Оператор декремента на величину x **/
    LongReal tmp(*this);        // Создаем копию текущего объекта
    tmp = *this - x;            // Производим вычитание
    swap(tmp);                  // Обмениваемся содержимым с копией
    return *this;               // Возвращаем текущий объект
//    return (*this = *this - x);
}   // LongReal::operator-=

LongReal& LongReal::operator+=(const LongReal& x) {
/** Оператор инкремента на величину x **/
    LongReal tmp(*this);        // Создаем копию текущего объекта
    tmp = *this + x;            // Производим сложение
    swap(tmp);                  // Обмениваемся содержимым с копией
    return *this;               // Возвращаем текущий объект
//    return (*this = *this - x);
}   // LongReal::operator-=

LongReal LongReal::inverse() const {
/** Вычисление обратного числа текущему (1/х)/ **/
    LongReal res;                               // Создаем объект для результата. При создании число равно нулю
    if(this->isposInf() || this->isnegInf()) {  // Если текущий экземпляр равен любой бесконечности, то
        res.sign = sign;                        // результирующий знак равен знаку нашего экземпляра и
        return res;                             // и возвращаем объект
    };
    if(this->isNaN()) {                         // Проверяем на NaN. Если NaN, то
        res.setNaN();                           // результат устанавливаем в NaN
        return res;                             // и возвращаем объект
    };
    if(this->isZero()) {                        // Если текущий экземпляр равен нулю, то
        res.setposinf();                        // во возвращаемом объекте устанавливаем плюс бесконечность и
        res.sign = sign;                        // результирующий знак равен знаку нашего экземпляра
        return res;                             // и возвращаем объект
    };
    LongReal x(*this);                  // Скопируем число,
	x.sign = false;                     // сделав его положительным
    LongReal d("1");                    // Cоздадим то, что будем делить на x и приравниваем единице
    res.sign = sign;                    // Знак результата совпадёт со знаком числа
    res.exponent = eOne;                // Начнём с единичной экспоненты
    while (x < d) {                     // Пока число меньше единицы,
		x.exponent++;                   // будем увеличивать его экспоненту (умножать на 10 фактически)
		res.exponent++;                 // и заодно экспоненту результата
	};
	while (d < x)                       // Сделаем число d большим x, также умножая его на 10,
		d.exponent++;                   // чтобы получить число 100...0
    res.exponent -= d.exponent - eOne;  // Подсчитаем реальное количество цифр в целой части
    size_t numbers = sZero;             // Количество уже вычисленных цифр дробной части
    Etype intPart = max(eZero, res.exponent);           // Число цифр целой части
    size_t maxNumbers = manDigits + (size_t)intPart;    // Максимальное число цифр массива
    Dtype* tmp = new Dtype[maxNumbers];                 // Выделяем память вспомогательному массиву
    if(!tmp) {                                          // Если память не выделена, то
        res.setNaN();                                   // устанавливаем результат в NaN
        return res;                                     // и выходим
    };
    for(size_t i=sZero; i<maxNumbers; i++)              // Обнуляем каждый элемент массива
        *(tmp+i) = dZero;
    do {
        Dtype div = dZero;              // Начинаем с нуля
        while (d >= x) {                // Считаем, сколько раз нужно вычесть x из d:
            div++;                      // сохраняем ето значение в div
            d -= x;                     // уменьшаем d на величину x
        };
        d.exponent++;                   // Увеличиваем остаток в 10 раз
        *(tmp+numbers) = div;           // Записываем сформированную цифру в массив цифр
        numbers++;                      // Увеличиваем число вычисленных цифр
    } while((!d.isZero()) &&(numbers < maxNumbers) );   // и делаем все это пока d не станет равным нулю и не достигнут лимит
    res.NumCount=maxNumbers;
    res.digits=tmp;                     // Устанавливаем указатель на массив с цифрами
    res.normalize();                    // Нормализуем число
    res.Resize(manDigits);              // Обрезаем мантиссу до указанного значения
    return res;
}   // LongReal::inverse()

LongReal LongReal::operator/(const LongReal& x) const {
/** Перегрузка оператора деления **/
    LongReal res;                           // Создаем объект для результата
    if( ((this->isposInf() || this->isnegInf()) && (x.isposInf() || x.isnegInf())) ||\
        (this->isZero() && x.isZero()) ) {  // Если оба числа равны бесконечности или оба равны нулю, то
        res.setNaN();                       // устанавливаем результат в NaN
        return res;                         // и выходим
    };
    if(*this == x) {                        // Если числа равны друг другу, то
        res = 1;                            // устанавливаем результат в единицу
        return res;                         // и возвращаем ее
    };
    res = *this * x.inverse();              // Выполняем умножение на обратное значение x
    return res;
}   // LongReal::operator/

bool LongReal::StF(ofstream &_outF) const {
/** Запись текущего экземпляра класса в файловую переменную типа ofstream. Параметры:
_outF - экземпляр класса ofstream для записи данных **/
    #ifdef Debug_voice
        long bpos = _outF.tellp();                    // Определяем позицию в начале файла
        cout << "LongReal::StF begin bpos= " << bpos << endl;
    #endif // Debug_voice
    if(!SEF(_outF, NumCount)) return false;             // Сохраняем количество цифр в числе (длину массива digits)
    if(!SEF(_outF, sign)) return false;                 // Сохраняем знак числа
    if(!SEF(_outF, exponent)) return false;             // Сохраняем экспоненту числа
    if(NumCount != sZero)                               // Если количество цифр не равно нулю (непустой массив), то
        if(!SEF(_outF, digits, NumCount)) return false; // сохраняем массив цифр
    #ifdef Debug_voice
        long epos = _outF.tellp();                    // Определяем позицию в конце файла
        cout << "LongReal::StF end epos= " << epos << endl;
    #endif // Debug_voice
    return true;
}   // LongReal::StF

bool LongReal::SaveToFile(const string _filename) const {
/** Метод записи текущего экземпляра класса в файл **/
    if(_filename == EmpStr) return false;               // Если имя файла пустое, то выход и возврат false
    ofstream outF(_filename, ios::out | ios::binary);   // Связываем имя файла с файловым потоком для записи на диск
    if (!outF.is_open()) {                              // Если файл не создан, то сообщение пользователю и
        cout << "Ошибка открытия файла" <<endl;         // возврат false и выход из функции
        return false;
    };
    if(!StF(outF)) {                                    // Записываем данные в файл. Если файл не записан, то
        outF.close();                                   // закрыаем файл и
        return false;                                   // выходим с false
    };
    outF.close();                                       // Закрываем файл
    return true;                                        // Возвращаем true
}   // LongReal::SaveToFile

bool LongReal::RfF(ifstream &_inF) {
/** Чтение из файловой переменной типа ifstream в текущий экземпляр класса. Параметры:
_inF - экземпляр класса ifstream для чтения данных **/
    #ifdef Debug_voice
        long bpos = _inF.tellg();                     // Определяем позицию в начале файла
        cout << "LongReal::RfF begin bpos= " << bpos << endl;
    #endif // Debug_voice
    LongReal tmp;                                       // Создаем вспомогательную переменную, будем читать в нее
    if(!DSF(_inF, tmp.NumCount)) return false;          // Читаем количество цифр в числе (длину массива digits)
    if(!DSF(_inF, tmp.sign)) return false;              // Читаем знак числа
    if(!DSF(_inF, tmp.exponent)) return false;          // Читаем экспоненту числа
    if(tmp.NumCount !=sZero) {                          // Если количество цифр не равно нулю (непустой массив), то
        tmp.digits = new(nothrow) Dtype[tmp.NumCount];          // Выделяем память новому массиву
        if(!tmp.digits) return false;                           // Если память не выделена, то выход с false
        if(!DSF(_inF, tmp.digits, tmp.NumCount)) return false;  // читаем массив цифр
    }
    else {
        tmp.digits = nullptr;                           // Иначе устанавливаем указатель массива в nullptr
        #ifdef Debug_voice
            long epos = _inF.tellg();                   // Определяем позицию в конце файла
            cout << "LongReal::RfF end epos= " << epos << endl;
        #endif // Debug_voice
    };
    #ifdef Debug_voice
        long epos = _inF.tellg();                    // Определяем позицию в конце файла
        cout << "LongReal::RfF end epos= " << epos << endl;
    #endif // Debug_voice
    swap(tmp);                                          // Обмениваемся данными с текущим экземпляром
    return true;                                        // и выходим с true
}   // LongReal::RfF

bool LongReal::ReadFromFile(const string _filename) {
/** Метод чтения из файла и запись в текущий экземпляр класса **/
    if(_filename == EmpStr) return false;               // Если имя файла пустое, то выход и возврат false
    ifstream inF(_filename, ios::in | ios::binary);     // Связываем имя файла с файловым потоком для чтения с диска
    if (!inF.is_open()) {                               // Если файл не открыт, то сообщение пользователю и
        cout << "Ошибка открытия файла" <<endl;         // возврат false и выход из функции
        return false;
    };
    if(!RfF(inF)) {                                     // Считываем данные из файла. Если файл не записан, то
        inF.close();                                    // Закрываем файл
        return false;                                   // Выход и возврат false
    };
    inF.close();                                        // Закрываем файл
    return true;                                        // Возвращаем true
}   // ReadFromFile

/********************************** Дружственные классу LongReal методы *************************************************/

    bool SEF(ofstream &_outF, LongReal& x) {
    /** Перегрузка метода SEF для типа LongReal **/
        if(!x.StF(_outF)) return false;
        else return true;
    }   // SEF


    bool SEF(ofstream &_outF, LongReal x[], size_t Cnt) {
    /** Перегрузка метода SEF для типа LongReal **/
        bool flag;                      // Флаг существования массива. Если указатель на массив не равен nullptr
        if(x && Cnt>nmSrlz::sZero) flag = true; else flag = false;  // и длина массива больше нуля, флаг true. Иначе false
        _outF.write((char*)&flag, sizeof(bool));                    // Записываем флаг в поток
        if(_outF.bad()) return false;   // Проверка состояния флага ошибки badbit (https://cplusplus.com/reference/ios/ios/rdstate/)
        if(flag)                        // Если флаг true, то записываем массив в поток
            for(size_t j{}; j<Cnt; j++) {
                if(!(x+j)->StF(_outF)) return false;
            };
        return true;
    }   // SEF


    bool DSF(ifstream &_inF, LongReal& x) {
    /** Перегрузка метода DSF для типа LongReal **/
        if(!x.RfF(_inF)) return false;
        else return true;
    }   // DSF


    bool DSF(ifstream &_inF, LongReal x[], size_t Cnt) {
    /** Перегрузка метода DSF для типа LongReal **/
        bool flag;                                          // Флаг существования массива
        _inF.read((char*)&flag, sizeof(bool));              // Читаем флаг из файла
        if(_inF.bad()) return false;
        if(flag) {
            for(size_t i{}; i<Cnt; i++)
                if(!(x+i)->RfF(_inF)) return false;
        } else x = nullptr;
        return true;
    }   // DSF

ostream& operator<<(ostream& os, const LongReal& value) {
/** Перегрузка оператора вывода числа в поток ostream **/
//    os << value.getstream();
//    string tmp = value.getstream().str(); // Выводим число, как string
    double tmp;
    value.getstream() >> tmp;               // Выводим число, как double
//    os << fixed << setprecision(mant) << tmp;
    os << tmp;
	return os;
}   // operator<<

ostream& operator>>(stringstream& ss, LongReal& value) {
/** Перегрузка оператора ввода информации из потока stringstream **/
    LongReal tmp(ss.str());
    value.swap(tmp);
    return ss;
}   // operator>>

LongReal fabs(const LongReal& x) {
/** Возвращает модуль числа x **/
    LongReal res(x);    // Копируем число
	res.sign = false;   // Меняем знак числа на "плюс"
    return res;
}   // LongReal::fabs



#undef Debug_voice

